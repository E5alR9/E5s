-- [[ ğŸª å®‡å®™ç³»çµ± 135.0 - 1min=1yr / æ æ—¥æµæ˜Ÿ / FPS 100 å¹³è¡¡ / å·¦å°é½Šç‰ˆ ]]
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local p = game:GetService("Players").LocalPlayer
local solarTag = "Universe_System_V135"

-- ã€1. é–‹é—œæ ¸å¿ƒé‚è¼¯ã€‘
local existing = workspace:FindFirstChild(solarTag)
if existing then
	_G.solarActive = false; existing:Destroy()
	if _G.oldEnvV135 then
		Lighting.ClockTime, Lighting.Brightness, Lighting.OutdoorAmbient = _G.oldEnvV135.T, _G.oldEnvV135.B, _G.oldEnvV135.O
	end
	return 
end

_G.oldEnvV135 = {T = Lighting.ClockTime, B = Lighting.Brightness, O = Lighting.OutdoorAmbient}
_G.solarActive = true
local currentSession, lastMeteorTime = tick(), 0
_G.solarSession = currentSession

Lighting.ClockTime, Lighting.Brightness, Lighting.OutdoorAmbient = 0, 0, Color3.new(0, 0, 0)
local container = Instance.new("Model", workspace)
container.Name = solarTag

-- ã€2. æ™‚é–“èˆ‡æ¯”ä¾‹è¨­å®šã€‘
local YEAR_DURATION = 60 
local BASE_SPEED = (math.pi * 2) / YEAR_DURATION 
local pConfigs = {
	{Name = "Mercury", Col = Color3.fromRGB(170, 170, 170), Rad = 500,  RelSpd = 1/0.24,  Size = 12},
	{Name = "Venus",   Col = Color3.fromRGB(255, 220, 100), Rad = 750,  RelSpd = 1/0.61,  Size = 22},
	{Name = "Earth",   Col = Color3.fromRGB(50, 150, 255),  Rad = 1000, RelSpd = 1/1,     Size = 24},
	{Name = "Mars",    Col = Color3.fromRGB(255, 100, 50),  Rad = 1300, RelSpd = 1/1.88,  Size = 16},
	{Name = "Jupiter", Col = Color3.fromRGB(220, 180, 140), Rad = 1800, RelSpd = 1/11.86, Size = 55}
}

-- ã€3. æ æ—¥æµæ˜Ÿå‡½æ•¸ (é–å®šå¤ªé™½ä¸­å¿ƒ)ã€‘
local function spawnSunSkimmer(sunCenter)
	local m = Instance.new("Part", container)
	m.Shape, m.Size, m.Material = Enum.PartType.Ball, Vector3.new(3, 3, 3), Enum.Material.Neon
	m.Color, m.Anchored, m.CanCollide = Color3.new(1,1,1), true, false
	local att0, att1 = Instance.new("Attachment", m), Instance.new("Attachment", m)
	att1.Position = Vector3.new(0,0,25) -- è¶…é•·æ‹–å°¾
	local tr = Instance.new("Trail", m)
	tr.Attachment0, tr.Attachment1, tr.Lifetime = att0, att1, 0.6
	tr.Color = ColorSequence.new(Color3.new(1,1,1), Color3.fromRGB(255, 150, 50)) -- é è¿‘å¤ªé™½å—ç†±è®Šæ©˜è‰²
	
	-- ç”Ÿæˆé‚è¼¯ï¼šå¾å¤ªé™½å¾Œæ–¹å°„å‘å¤ªé™½å‰æ–¹
	local angle = math.rad(math.random(360))
	local dist = 3500
	-- èµ·é»èˆ‡çµ‚é»é€£ç·šæœƒç¶“éå¤ªé™½ä¸­å¿ƒé»é™„è¿‘ (åŠ ä¸Šéš¨æ©Ÿåç§»ä»¥å…æ¯æ¬¡éƒ½æ­£ä¸­ç´…å¿ƒ)
	local offset = Vector3.new(math.random(-150, 150), math.random(-150, 150), math.random(-150, 150))
	local startPos = sunCenter + Vector3.new(math.cos(angle)*dist, math.random(-200, 200), math.sin(angle)*dist)
	local endPos = sunCenter - (startPos - sunCenter) + offset -- å°è§’ç·šç™¼å°„
	
	task.spawn(function()
		local a = 0
		local speed = 0.015 + (math.random() * 0.01)
		while a < 1 and _G.solarActive do
			a = a + speed
			m.Position = startPos:Lerp(endPos, a)
			RunService.RenderStepped:Wait()
		end
		m:Destroy()
	end)
end

-- ã€4. å¤ªé™½èˆ‡è¡Œæ˜Ÿåˆå§‹åŒ–ã€‘
local activeSun, inactiveSun = {}, {}
for i = 1, 5000 do
	local offset, inc = 2/5000, math.pi*(3-math.sqrt(5))
	local y = ((i-1)*offset-1)+(offset/2)
	local r, phi = math.sqrt(1-y^2), i*inc
	local d = {Size = (i%2==0) and Vector3.new(12,12,12) or Vector3.new(24,24,24), RY = r*280, Y = y*280, Phi = phi, Lat = y, Obj = nil}
	local pPart = Instance.new("Part", container)
	pPart.Size, pPart.Material, pPart.Anchored, pPart.CanCollide = d.Size, Enum.Material.Neon, true, false
	d.Obj = pPart; table.insert(activeSun, d)
end

local planets = {}
for _, cfg in ipairs(pConfigs) do
	local g = {}
	for j = 1, 300 do
		local pt = Instance.new("Part", container)
		pt.Shape, pt.Size, pt.Material, pt.Color = Enum.PartType.Ball, Vector3.new(6,6,6), Enum.Material.Neon, cfg.Col
		pt.Anchored, pt.CanCollide = true, false
		table.insert(g, {Obj = pt, LPos = Vector3.new(math.random()-0.5, math.random()-0.5, math.random()-0.5).Unit * cfg.Size})
	end
	table.insert(planets, {Parts = g, Config = cfg, Angle = math.random()*6})
end

-- ã€5. æ¸²æŸ“èˆ‡ FPS å¹³è¡¡å¾ªç’°ã€‘
task.spawn(function()
	local t, fps = 0, 144
	local tilt = CFrame.Angles(math.rad(10), 0, math.rad(5))

	while _G.solarActive and _G.solarSession == currentSession do
		local dt = RunService.RenderStepped:Wait()
		fps = 0.9 * fps + 0.1 * (1 / dt)
		t = t + dt

		local char = p.Character and p.Character:FindFirstChild("HumanoidRootPart")
		if char then
			local rp = char.Position
			local sunCenter = rp + Vector3.new(1200, 500, -1200)

			-- FPS 100 å®ˆè­·
			if fps < 100 and #activeSun > 200 then
				for k = 1, 50 do
					local d = table.remove(activeSun, math.random(#activeSun))
					if d.Obj then d.Obj:Destroy(); d.Obj = nil; table.insert(inactiveSun, d) end
				end
			elseif fps > 115 and #inactiveSun > 0 then
				for k = 1, 30 do
					local d = table.remove(inactiveSun, math.random(#inactiveSun))
					local pPart = Instance.new("Part", container)
					pPart.Size, pPart.Material, pPart.Anchored, pPart.CanCollide = d.Size, Enum.Material.Neon, true, false
					d.Obj = pPart; table.insert(activeSun, d)
				end
			end

			-- è§¸ç™¼æ æ—¥æµæ˜Ÿ
			if tick() - lastMeteorTime > math.random(8, 15) then
				spawnSunSkimmer(sunCenter)
				lastMeteorTime = tick()
			end

			-- å¤ªé™½æ¸²æŸ“
			for _, d in ipairs(activeSun) do
				if d.Obj then
					local curPhi = d.Phi + t * 0.1
					d.Obj.Color = Color3.fromRGB(255, 40, 0):lerp(Color3.fromRGB(255, 180, 0), (math.sin(d.Lat*15+t*2)+1)/2)
					d.Obj.Position = sunCenter + (tilt * Vector3.new(math.cos(curPhi)*d.RY, d.Y, math.sin(curPhi)*d.RY))
				end
			end

			-- è¡Œæ˜Ÿæ¸²æŸ“
			for _, pl in ipairs(planets) do
				pl.Angle = pl.Angle + (BASE_SPEED * pl.Config.RelSpd * dt)
				local pPos = sunCenter + (tilt * Vector3.new(math.cos(pl.Angle)*pl.Config.Rad, 0, math.sin(pl.Angle)*pl.Config.Rad))
				for _, mp in ipairs(pl.Parts) do mp.Obj.Position = pPos + mp.LPos end
			end
		end
	end
end)
