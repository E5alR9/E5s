-- [[ 粒子黑洞：FPS 低於 100 自動刪除粒子 + 280 最佳距離 ]]
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local p = game:GetService("Players").LocalPlayer
local holeTag = "E5_Vortex_Auto_Delete"

local existingHole = workspace:FindFirstChild(holeTag)

if existingHole then
	_G.skyEnabled = false
	existingHole:Destroy()
	
	if _G.oldBlackHoleLighting then
		Lighting.ClockTime = _G.oldBlackHoleLighting.Time
		Lighting.Brightness = _G.oldBlackHoleLighting.Brightness
		Lighting.OutdoorAmbient = _G.oldBlackHoleLighting.Outdoor
		_G.oldBlackHoleLighting = nil
	else
		Lighting.ClockTime = 14
		Lighting.Brightness = 2
		Lighting.OutdoorAmbient = Color3.fromRGB(127, 127, 127)
	end
	return
else
	_G.skyEnabled = true
	_G.oldBlackHoleLighting = {
		Time = Lighting.ClockTime,
		Brightness = Lighting.Brightness,
		Outdoor = Lighting.OutdoorAmbient
	}

	Lighting.ClockTime = 0
	Lighting.Brightness = 0
	Lighting.OutdoorAmbient = Color3.fromRGB(0, 0, 0)

	local function saturate(v) return math.clamp(v, 0, 1) end
	local function shaderTonemap(c)
		local p1, p2 = 2.2, 1/2.2
		local x = (c.X^p1)/(1+c.X^p1)
		local y = (c.Y^p1)/(1+c.Y^p1)
		local z = (c.Z^p1)/(1+c.Z^p1)
		return Vector3.new(x^p2, y^p2, z^p2)
	end

	local container = Instance.new("Model", workspace)
	container.Name = holeTag

	local core = Instance.new("Part", container)
	core.Shape, core.Size = Enum.PartType.Ball, Vector3.new(42, 42, 42)
	core.Color, core.Material = Color3.new(0, 0, 0), Enum.Material.Neon
	core.CanCollide, core.Anchored = false, true

	local orbs = {}
	local orbCount = 15000 

	for i = 1, orbCount do
		local part = Instance.new("Part", container)
		part.Shape, part.Size = Enum.PartType.Ball, Vector3.new(0.5, 0.5, 0.5)
		part.Material, part.CanCollide, part.Anchored = Enum.Material.Neon, false, true
		
		local tr = Instance.new("Trail", part)
		local a0, a1 = Instance.new("Attachment", part), Instance.new("Attachment", part)
		a1.Position = Vector3.new(0, 0.2, 0)
		tr.Attachment0, tr.Attachment1 = a0, a1
		tr.Lifetime, tr.WidthScale = 0.1, NumberSequence.new(0.8, 0)

		local prog = i / orbCount
		local baseRadius = 22 + (math.sqrt(prog) * 65) 
		
		table.insert(orbs, {
			Part = part,
			Angle = math.random() * math.pi * 2,
			BaseRadius = baseRadius,
			DriftSpeed = 0.5 + math.random(),
			DriftAmount = 5 + math.random(0, 15), 
			RotSpeed = (0.25 + math.random() * 0.15) / (baseRadius^0.4),
			Seed = math.random(1, 100000),
			YOffset = (math.random() - 0.5) * (baseRadius * 0.1)
		})
	end

	task.spawn(function()
		local t = 0
		local tilt = CFrame.Angles(math.rad(25), 0, math.rad(15)) 
		local fps = 144
		
		while container.Parent and _G.skyEnabled do
			local dt = RunService.RenderStepped:Wait()
			fps = 0.9 * fps + 0.1 * (1 / dt)
			t = t + 0.04
			
			local char = p.Character
			local root = char and char:FindFirstChild("HumanoidRootPart")
			
			if root then
				-- 【距離回歸 280：保持穩定壓迫感】
				local centerPos = root.Position + Vector3.new(280, 120, -150)
				core.Position = centerPos
				
				-- 自動刪除邏輯：若 FPS 低於 100，每幀強制移除 30 個粒子直到回升
				if fps < 100 and #orbs > 500 then
					for i = 1, 30 do
						local targetIdx = #orbs -- 從最外圈開始刪除
						local data = orbs[targetIdx]
						if data then
							if data.Part then data.Part:Destroy() end
							table.remove(orbs, targetIdx)
						end
					end
				end

				-- 渲染循環
				for _, data in ipairs(orbs) do
					data.Angle = data.Angle + data.RotSpeed
					local drift = math.sin(t * data.DriftSpeed + data.Seed) * data.DriftAmount
					local currentR = data.BaseRadius + drift
					
					local x = math.cos(data.Angle) * currentR
					local z = math.sin(data.Angle) * currentR
					local y = data.YOffset + (math.sin(t + data.Seed) * 2)
					
					local distFactor = (currentR - 22) / 80
					local rawCol
					
					if distFactor < 0.15 then
						rawCol = Vector3.new(15, 18, 25) 
					elseif distFactor < 0.55 then
						rawCol = Vector3.new(12, 4, 0.5) 
					else
						rawCol = Vector3.new(2, 0.5, 10) 
					end
					
					data.Part.Position = centerPos + (tilt * Vector3.new(x, y, z))
					local flicker = 1 + math.sin(t * 5 + data.Seed) * 0.2
					local finalC = shaderTonemap(rawCol * flicker)
					data.Part.Color = Color3.new(saturate(finalC.X), saturate(finalC.Y), saturate(finalC.Z))
				end
			end
		end
	end)
end
