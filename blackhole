-- [[ ğŸŒŒ ç²’å­é»‘æ´ 11.0 - éš¨æ©Ÿå¯†åº¦å¹³è¡¡ (ä¸æ”¹å¸ç©ç›¤é•·åº¦) ]]
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local p = game:GetService("Players").LocalPlayer
local holeTag = "E5_Vortex_DynamicBalance"

local existingHole = workspace:FindFirstChild(holeTag)

if existingHole then
	_G.skyEnabled = false
	existingHole:Destroy()
	
	if _G.oldBlackHoleLighting then
		Lighting.ClockTime = _G.oldBlackHoleLighting.Time
		Lighting.Brightness = _G.oldBlackHoleLighting.Brightness
		Lighting.OutdoorAmbient = _G.oldBlackHoleLighting.Outdoor
		_G.oldBlackHoleLighting = nil
	else
		Lighting.ClockTime = 14
		Lighting.Brightness = 2
		Lighting.OutdoorAmbient = Color3.fromRGB(127, 127, 127)
	end
	return
else
	_G.skyEnabled = true
	_G.oldBlackHoleLighting = {
		Time = Lighting.ClockTime,
		Brightness = Lighting.Brightness,
		Outdoor = Lighting.OutdoorAmbient
	}

	Lighting.ClockTime = 0
	Lighting.Brightness = 0
	Lighting.OutdoorAmbient = Color3.fromRGB(0, 0, 0)

	local function saturate(v) return math.clamp(v, 0, 1) end
	local function shaderTonemap(c)
		local p1, p2 = 2.2, 1/2.2
		local x = (c.X^p1)/(1+c.X^p1)
		local y = (c.Y^p1)/(1+c.Y^p1)
		local z = (c.Z^p1)/(1+c.Z^p1)
		return Vector3.new(x^p2, y^p2, z^p2)
	end

	local container = Instance.new("Model", workspace)
	container.Name = holeTag

	local core = Instance.new("Part", container)
	core.Shape, core.Size = Enum.PartType.Ball, Vector3.new(42, 42, 42)
	core.Color, core.Material = Color3.new(0, 0, 0), Enum.Material.Neon
	core.CanCollide, core.Anchored = false, true

	local activeOrbs = {}   -- å ´ä¸Šçš„ç²’å­
	local inactivePool = {} -- è¢«æš«æ™‚åˆªé™¤çš„æ•¸æ“šæ± 
	local orbCount = 15000 

	-- åˆå§‹åŒ–æ•¸æ“šï¼ˆä¿æŒä½ åŸå§‹çš„åŠå¾‘æ•¸å­¸å…¬å¼ï¼‰
	for i = 1, orbCount do
		local prog = i / orbCount
		local baseRadius = 22 + (math.sqrt(prog) * 65) 
		
		local data = {
			BaseRadius = baseRadius,
			Angle = math.random() * math.pi * 2,
			DriftSpeed = 0.5 + math.random(),
			DriftAmount = 5 + math.random(0, 15),
			RotSpeed = (0.25 + math.random() * 0.15) / (baseRadius^0.4),
			Seed = math.random(1, 100000),
			YOffset = (math.random() - 0.5) * (baseRadius * 0.1),
			Part = nil
		}

		-- åˆå§‹åŠ è¼‰æ‰€æœ‰å¯¦é«”
		local part = Instance.new("Part", container)
		part.Shape, part.Size = Enum.PartType.Ball, Vector3.new(0.5, 0.5, 0.5)
		part.Material, part.CanCollide, part.Anchored = Enum.Material.Neon, false, true
		
		local tr = Instance.new("Trail", part)
		local a0, a1 = Instance.new("Attachment", part), Instance.new("Attachment", part)
		a1.Position = Vector3.new(0, 0.2, 0)
		tr.Attachment0, tr.Attachment1 = a0, a1
		tr.Lifetime, tr.WidthScale = 0.1, NumberSequence.new(0.8, 0)
		
		data.Part = part
		table.insert(activeOrbs, data)
	end

	task.spawn(function()
		local t, fps = 0, 144
		local tilt = CFrame.Angles(math.rad(25), 0, math.rad(15)) 
		
		while container.Parent and _G.skyEnabled do
			local dt = RunService.RenderStepped:Wait()
			fps = 0.9 * fps + 0.1 * (1 / dt)
			t = t + 0.04
			
			local char = p.Character
			local root = char and char:FindFirstChild("HumanoidRootPart")
			
			if root then
				local centerPos = root.Position + Vector3.new(280, 120, -150)
				core.Position = centerPos
				
				-- ã€é»‘æ´éš¨æ©Ÿå¹³è¡¡é‚è¼¯ã€‘
				if fps < 100 and #activeOrbs > 500 then
					-- éš¨æ©Ÿåˆªé™¤ç²’å­ï¼Œå¯†åº¦é™ä½ä½†ç›¤ä¸ç¸®çŸ­
					for i = 1, 40 do
						local rIdx = math.random(#activeOrbs)
						local data = table.remove(activeOrbs, rIdx)
						if data and data.Part then
							data.Part:Destroy()
							data.Part = nil
							table.insert(inactivePool, data)
						end
					end
				elseif fps > 115 and #inactivePool > 0 then
					-- éš¨æ©Ÿè£œå›ç²’å­
					for i = 1, 20 do
						local rIdx = math.random(#inactivePool)
						local data = table.remove(inactivePool, rIdx)
						if data then
							local part = Instance.new("Part", container)
							part.Shape, part.Size = Enum.PartType.Ball, Vector3.new(0.5, 0.5, 0.5)
							part.Material, part.CanCollide, part.Anchored = Enum.Material.Neon, false, true
							
							local tr = Instance.new("Trail", part)
							local a0, a1 = Instance.new("Attachment", part), Instance.new("Attachment", part)
							a1.Position = Vector3.new(0, 0.2, 0)
							tr.Attachment0, tr.Attachment1 = a0, a1
							tr.Lifetime, tr.WidthScale = 0.1, NumberSequence.new(0.8, 0)
							
							data.Part = part
							table.insert(activeOrbs, data)
						end
					end
				end

				-- æ¸²æŸ“æ‰€æœ‰å­˜åœ¨çš„ç²’å­
				for _, data in ipairs(activeOrbs) do
					data.Angle = data.Angle + data.RotSpeed
					local drift = math.sin(t * data.DriftSpeed + data.Seed) * data.DriftAmount
					local currentR = data.BaseRadius + drift
					
					local x = math.cos(data.Angle) * currentR
					local z = math.sin(data.Angle) * currentR
					local y = data.YOffset + (math.sin(t + data.Seed) * 2)
					
					local distFactor = (currentR - 22) / 80
					local rawCol
					
					if distFactor < 0.15 then
						rawCol = Vector3.new(15, 18, 25) 
					elseif distFactor < 0.55 then
						rawCol = Vector3.new(12, 4, 0.5) 
					else
						rawCol = Vector3.new(2, 0.5, 10) 
					end
					
					data.Part.Position = centerPos + (tilt * Vector3.new(x, y, z))
					local flicker = 1 + math.sin(t * 5 + data.Seed) * 0.2
					local finalC = shaderTonemap(rawCol * flicker)
					data.Part.Color = Color3.new(saturate(finalC.X), saturate(finalC.Y), saturate(finalC.Z))
				end
			end
		end
	end)
end
