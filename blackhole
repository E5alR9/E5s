-- [[ 粒子黑洞：隨機震盪 + 距離顯色獨立開關版 ]]
local p = game:GetService("Players").LocalPlayer
local holeTag = "E5_Vortex_Legacy_Custom"

-- 檢查目前狀態
local existingHole = workspace:FindFirstChild(holeTag)

if existingHole then
    _G.skyEnabled = false
    existingHole:Destroy()
    print("Vortex Closed")
else
    _G.skyEnabled = true

    -- 色彩處理工具
    local function saturate(v) return math.clamp(v, 0, 1) end
    local function shaderTonemap(c)
        local p1, p2 = 2.2, 1/2.2
        local x = (c.X^p1)/(1+c.X^p1)
        local y = (c.Y^p1)/(1+c.Y^p1)
        local z = (c.Z^p1)/(1+c.Z^p1)
        return Vector3.new(x^p2, y^p2, z^p2)
    end

    local container = Instance.new("Model", workspace)
    container.Name = holeTag

    -- 核心黑球
    local core = Instance.new("Part", container)
    core.Shape, core.Size = Enum.PartType.Ball, Vector3.new(42, 42, 42)
    core.Color, core.Material = Color3.new(0, 0, 0), Enum.Material.Neon
    core.CanCollide, core.Anchored = false, true

    local orbs = {}
    local orbCount = 15000 -- 粒子數量

    for i = 1, orbCount do
        local part = Instance.new("Part", container)
        part.Shape, part.Size = Enum.PartType.Ball, Vector3.new(0.5, 0.5, 0.5)
        part.Material, part.CanCollide, part.Anchored = Enum.Material.Neon, false, true
        
        -- 增加拖尾感
        local tr = Instance.new("Trail", part)
        local a0, a1 = Instance.new("Attachment", part), Instance.new("Attachment", part)
        a1.Position = Vector3.new(0, 0.2, 0)
        tr.Attachment0, tr.Attachment1 = a0, a1
        tr.Lifetime, tr.WidthScale = 0.1, NumberSequence.new(0.8, 0)

        local prog = i / orbCount
        -- 初始半徑分佈
        local baseRadius = 22 + (math.sqrt(prog) * 65) 
        
        table.insert(orbs, {
            Part = part,
            Angle = math.random() * math.pi * 2,
            BaseRadius = baseRadius,
            -- 隨機遠近幅度 (每個粒子的震盪頻率不同)
            DriftSpeed = 0.5 + math.random(),
            DriftAmount = 5 + math.random(0, 15), 
            RotSpeed = (0.25 + math.random() * 0.15) / (baseRadius^0.4),
            Seed = math.random(1, 100000),
            YOffset = (math.random() - 0.5) * (baseRadius * 0.1)
        })
    end

    -- 渲染主循環
    task.spawn(function()
        local t = 0
        local tilt = CFrame.Angles(math.rad(12), 0, math.rad(5)) -- 盤面傾斜
        
        while container.Parent and _G.skyEnabled do
            t = t + 0.04
            local char = p.Character
            local root = char and char:FindFirstChild("HumanoidRootPart")
            
            if root then
                local centerPos = root.Position + Vector3.new(0, 115, 0)
                core.Position = centerPos
                
                for _, data in ipairs(orbs) do
                    data.Angle = data.Angle + data.RotSpeed
                    
                    -- [功能 1: 隨機遠近震盪]
                    -- 利用正弦波模擬粒子在吸積盤內外的隨機漂移
                    local drift = math.sin(t * data.DriftSpeed + data.Seed) * data.DriftAmount
                    local currentR = data.BaseRadius + drift
                    
                    local x = math.cos(data.Angle) * currentR
                    local z = math.sin(data.Angle) * currentR
                    local y = data.YOffset + (math.sin(t + data.Seed) * 2)
                    
                    -- [功能 2: 顏色以距離決定]
                    -- 根據當前半徑 (currentR) 計算顏色區間
                    local distFactor = (currentR - 22) / 80
                    local rawCol
                    
                    if distFactor < 0.15 then
                        -- 內圈：高能藍白光
                        rawCol = Vector3.new(15, 18, 25) 
                    elseif distFactor < 0.55 then
                        -- 中圈：熱能橙黃色
                        rawCol = Vector3.new(12, 4, 0.5) 
                    else
                        -- 外圈：幽冥紫色
                        rawCol = Vector3.new(2, 0.5, 10) 
                    end
                    
                    -- 設置位置與 Tonemap 色彩轉換
                    data.Part.Position = centerPos + (tilt * Vector3.new(x, y, z))
                    local flicker = 1 + math.sin(t * 5 + data.Seed) * 0.2
                    local finalC = shaderTonemap(rawCol * flicker)
                    data.Part.Color = Color3.new(saturate(finalC.X), saturate(finalC.Y), saturate(finalC.Z))
                end
            end
            task.wait()
        end
    end)
    print("Vortex Opened with Drift & Dynamic Coloring")
end
