local StarterGui = game:GetService("StarterGui")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")

-- [ 參數設定 ] --
local FLOOR_SIZE_THRESHOLD = 40   -- [地板判定] 接觸物體 > 40 視為地板 (防止掉入虛空)
local MIN_SIZE_FOR_MODE_1 = 200   -- [模式1標準] 模式1只刪除 > 200 的牆壁

-- 初始化全局變數
if _G.WallMode == nil then _G.WallMode = 0 end 
if _G.StoredWalls == nil then _G.StoredWalls = {} end

-- 切換模式 (0 -> 1 -> 2 -> 0)
_G.WallMode = _G.WallMode + 1
if _G.WallMode > 2 then _G.WallMode = 0 end

-- 輔助函數：判斷是否為斜坡
local function isSlope(part)
	if part:IsA("WedgePart") or part:IsA("CornerWedgePart") then return true end
	local rotX = math.abs(part.Orientation.X) % 90
	local rotZ = math.abs(part.Orientation.Z) % 90
	local threshold = 2 
	if (rotX > threshold and rotX < (90 - threshold)) or (rotZ > threshold and rotZ < (90 - threshold)) then
		return true 
	end
	return false
end

-- ==========================================
-- [ 模式 0 ] : 恢復原狀 (Restored)
-- ==========================================
if _G.WallMode == 0 then
	local restoreCount = 0
	if _G.StoredWalls then
		for _, v in pairs(_G.StoredWalls) do
			if v then 
				v.CanCollide = true 
				restoreCount = restoreCount + 1
			end
		end
	end
	_G.StoredWalls = {} -- 清空儲存表
	
	StarterGui:SetCore("SendNotification", {
		Title = "Normal";
		Text = "Restored " .. restoreCount .. " walls.\n(Back to default)";
		Duration = 3;
	})

-- ==========================================
-- [ 模式 1 ] : 智慧刪除 (只刪大牆)
-- ==========================================
elseif _G.WallMode == 1 then
	local count = 0
	local checkCount = 0
	local params = OverlapParams.new()
	params.FilterType = Enum.RaycastFilterType.Exclude
	params.FilterDescendantsInstances = {Workspace.Terrain}

	-- 掃描全圖
	for _, v in pairs(Workspace:GetDescendants()) do
		if v:IsA("BasePart") and v.Transparency == 1 and v.CanCollide then
			checkCount = checkCount + 1
			if checkCount % 200 == 0 then task.wait() end

			-- 保護機制 1: 斜坡
			if isSlope(v) then continue end

			-- 保護機制 2: 尺寸太小 (< 200) 則保留
			local maxSize = math.max(v.Size.X, v.Size.Y, v.Size.Z)
			if maxSize < MIN_SIZE_FOR_MODE_1 then continue end

			-- 保護機制 3: 地板判定 (避免誤刪包含地板的牆)
			local partsInside = Workspace:GetPartsInPart(v, params)
			local shouldKeep = false
			for _, touchingPart in pairs(partsInside) do
				if touchingPart.Transparency < 1 and touchingPart ~= v then
					if touchingPart.Size.X < FLOOR_SIZE_THRESHOLD and touchingPart.Size.Z < FLOOR_SIZE_THRESHOLD then
						shouldKeep = true
						break 
					end
				end
			end

			if not shouldKeep then
				table.insert(_G.StoredWalls, v)
				v.CanCollide = false
				count = count + 1
			end
		end
	end

	StarterGui:SetCore("SendNotification", {
		Title = "Smart Remove";
		Text = "Removed " .. count .. " LARGE walls.\n(Kept small details)";
		Duration = 3;
	})

-- ==========================================
-- [ 模式 2 ] : 全力刪除 (刪除所有隱形牆)
-- ==========================================
elseif _G.WallMode == 2 then
	local count = 0
	local checkCount = 0
	
	-- 這裡我們再次掃描，把模式1沒刪掉的小牆壁也刪了
	-- 已經被模式1刪掉的 (CanCollide=false) 會自動跳過
	for _, v in pairs(Workspace:GetDescendants()) do
		if v:IsA("BasePart") and v.Transparency == 1 and v.CanCollide then
			checkCount = checkCount + 1
			if checkCount % 200 == 0 then task.wait() end

			-- 即使是暴力模式，也要保留斜坡，不然樓梯會壞掉
			if isSlope(v) then continue end
			
			-- 注意：這裡移除了「尺寸 < 200」的保護！

			-- 還是要有基本的防掉落保護 (只保留純地板)
			-- 如果這個牆壁"只"接觸到超大地板，那就視為地板的一部分，不刪
			-- 如果它是懸空的或者接觸小東西，刪！
			
			-- 簡單邏輯：暴力模式下，我們只保留斜坡。
			-- 如果你希望連小物件都刪，就不做重疊檢測了。
			
			table.insert(_G.StoredWalls, v)
			v.CanCollide = false
			count = count + 1
		end
	end

	StarterGui:SetCore("SendNotification", {
		Title = "Remove ALL";
		Text = "Removed " .. count .. " remaining small walls.\n(Total clean up)";
		Duration = 3;
	})
end
