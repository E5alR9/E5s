local StarterGui = game:GetService("StarterGui")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")

-- [ 參數設定 (保持跟你原本的一樣) ] --
local FLOOR_SIZE_THRESHOLD = 40   -- [地板判定]
local FORCE_REMOVE_FAR_COUNT = 6  -- [邊界清理]
local MIN_SIZE_TO_DELETE = 200    -- [尺寸保護]

-- 初始化變數
if _G.WallMode == nil then _G.WallMode = 0 end 
if _G.StoredWalls == nil then _G.StoredWalls = {} end

-- 切換模式 (0 -> 1 -> 2 -> 0)
_G.WallMode = _G.WallMode + 1
if _G.WallMode > 2 then _G.WallMode = 0 end

-- 判斷是否為斜坡 (保持不變)
local function isSlope(part)
	if part:IsA("WedgePart") or part:IsA("CornerWedgePart") then return true end
	local rotX = math.abs(part.Orientation.X) % 90
	local rotZ = math.abs(part.Orientation.Z) % 90
	local threshold = 2 
	if (rotX > threshold and rotX < (90 - threshold)) or (rotZ > threshold and rotZ < (90 - threshold)) then
		return true 
	end
	return false
end

-- ==========================================
-- [ 模式 0 ] : 恢復原狀 (Restored)
-- ==========================================
if _G.WallMode == 0 then
	local restoreCount = 0
	if _G.StoredWalls then
		for _, v in pairs(_G.StoredWalls) do
			if v then 
				v.CanCollide = true 
				restoreCount = restoreCount + 1
			end
		end
	end
	_G.StoredWalls = {} 
	
	StarterGui:SetCore("SendNotification", {
		Title = "Restored";
		Text = "Map is back to normal\n(Restored " .. restoreCount .. ")";
		Duration = 3;
	})

-- ==========================================
-- [ 模式 1 ] : 智慧刪除 (完全複製你原本的邏輯)
-- ==========================================
elseif _G.WallMode == 1 then
	local foundCount = 0
	local deletedCount = 0
	local checkCount = 0

	local params = OverlapParams.new()
	params.FilterType = Enum.RaycastFilterType.Exclude
	params.FilterDescendantsInstances = {Workspace.Terrain}
	
	-- 1. 掃描全圖 (和你原本的一模一樣)
	for _, v in pairs(Workspace:GetDescendants()) do
		if v:IsA("BasePart") and v.Transparency == 1 and v.CanCollide then
			foundCount = foundCount + 1
			checkCount = checkCount + 1
			if checkCount % 100 == 0 then task.wait() end

			if isSlope(v) then continue end -- 斜坡保護

			-- 尺寸保護
			local maxSize = math.max(v.Size.X, v.Size.Y, v.Size.Z)
			if maxSize < MIN_SIZE_TO_DELETE then continue end

			-- 內容物檢測 (你指定要保留的部分)
			local partsInside = Workspace:GetPartsInPart(v, params)
			local shouldKeep = false
			for _, touchingPart in pairs(partsInside) do
				if touchingPart.Transparency < 1 and touchingPart ~= v then
					if touchingPart.Size.X < FLOOR_SIZE_THRESHOLD and touchingPart.Size.Z < FLOOR_SIZE_THRESHOLD then
						shouldKeep = true
						break 
					end
				end
			end

			if not shouldKeep then
				table.insert(_G.StoredWalls, v)
				v.CanCollide = false
				deletedCount = deletedCount + 1
			end
		end
	end

	-- 2. 強制清理最遠邊界 (原本腳本有的，這裡補上了！)
	local plr = Players.LocalPlayer
	if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
		local root = plr.Character.HumanoidRootPart
		local candidates = {}

		for _, v in pairs(Workspace:GetDescendants()) do
			if v:IsA("BasePart") and v.Transparency == 1 and v.CanCollide and not isSlope(v) then
				local maxSize = math.max(v.Size.X, v.Size.Y, v.Size.Z)
				if maxSize >= MIN_SIZE_TO_DELETE then
					local dist = (v.Position - root.Position).Magnitude
					table.insert(candidates, {Part = v, Distance = dist})
				end
			end
		end

		table.sort(candidates, function(a, b) return a.Distance > b.Distance end)

		for i = 1, FORCE_REMOVE_FAR_COUNT do
			if candidates[i] then
				local target = candidates[i].Part
				if target.CanCollide == true then
					table.insert(_G.StoredWalls, target)
					target.CanCollide = false
					deletedCount = deletedCount + 1
				end
			end
		end
	end

	StarterGui:SetCore("SendNotification", {
		Title = "Smart Remove";
		Text = "Same effect as original.\nDeleted: " .. deletedCount;
		Duration = 3;
	})

-- ==========================================
-- [ 模式 2 ] : 暴力刪除 (刪除剩下的)
-- ==========================================
elseif _G.WallMode == 2 then
	local deletedCount = 0
	local checkCount = 0
	
	-- 這次不檢查尺寸，也不檢查內容物
	for _, v in pairs(Workspace:GetDescendants()) do
		if v:IsA("BasePart") and v.Transparency == 1 and v.CanCollide then
			checkCount = checkCount + 1
			if checkCount % 100 == 0 then task.wait() end

			if isSlope(v) then continue end -- 依然保留斜坡防卡死

			-- 直接刪除
			table.insert(_G.StoredWalls, v)
			v.CanCollide = false
			deletedCount = deletedCount + 1
		end
	end

	StarterGui:SetCore("SendNotification", {
		Title = "Remove ALL";
		Text = "Cleared remaining small walls.\n(Total Clean)";
		Duration = 3;
	})
end
