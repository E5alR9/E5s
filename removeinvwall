local StarterGui = game:GetService("StarterGui")
local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")

-- [ 參數設定 ] --
local FLOOR_SIZE_THRESHOLD = 40 -- 物體判定大小 (過大視為地板)
local FORCE_REMOVE_FAR_COUNT = 6 -- 強制刪除最遠邊界數量

-- 判斷是否為斜坡的函數
local function isSlope(part)
	if part:IsA("WedgePart") or part:IsA("CornerWedgePart") then return true end
	local rotX = math.abs(part.Orientation.X) % 90
	local rotZ = math.abs(part.Orientation.Z) % 90
	local threshold = 2 
	if (rotX > threshold and rotX < (90 - threshold)) or (rotZ > threshold and rotZ < (90 - threshold)) then
		return true 
	end
	return false
end

if not _G.WallsGone then
	-- [[ 開啟穿牆模式 ]] --
	_G.StoredWalls = {} 
	local foundCount = 0    -- 找到的總數
	local deletedCount = 0  -- 刪除的總數
	local checkCount = 0 

	local params = OverlapParams.new()
	params.FilterType = Enum.RaycastFilterType.Exclude
	params.FilterDescendantsInstances = {Workspace.Terrain}

	-- 1. 第一階段：掃描與智慧過濾
	local allParts = Workspace:GetDescendants()

	for _, v in pairs(allParts) do
		-- 基礎條件：透明且有碰撞
		if v:IsA("BasePart") and v.Transparency == 1 and v.CanCollide then
			
			foundCount = foundCount + 1 -- 發現一個隱形牆！計數 +1
			
			-- 防卡頓
			checkCount = checkCount + 1
			if checkCount % 100 == 0 then task.wait() end

			-- [A] 斜坡保護：如果是斜坡，跳過
			if isSlope(v) then
				continue 
			end

			-- [B] 重疊檢測：檢查是否包著細節模型
			local partsInside = Workspace:GetPartsInPart(v, params)
			local shouldKeep = false

			for _, touchingPart in pairs(partsInside) do
				if touchingPart.Transparency < 1 and touchingPart ~= v then
					-- 如果是小東西 (欄杆細節) 則保留
					if touchingPart.Size.X < FLOOR_SIZE_THRESHOLD and touchingPart.Size.Z < FLOOR_SIZE_THRESHOLD then
						shouldKeep = true
						break 
					end
				end
			end

			if not shouldKeep then
				-- 判定為垃圾牆，刪除！
				table.insert(_G.StoredWalls, v) 
				v.CanCollide = false            
				deletedCount = deletedCount + 1 -- 刪除數 +1
			end
		end
	end

	-- 2. 第二階段：強制清理邊界 (針對漏網之魚)
	local plr = Players.LocalPlayer
	if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
		local root = plr.Character.HumanoidRootPart
		local candidates = {}

		-- 重新掃描一次，這次只找「還活著」的隱形牆
		for _, v in pairs(Workspace:GetDescendants()) do
			if v:IsA("BasePart") and v.Transparency == 1 and v.CanCollide and not isSlope(v) then
				local dist = (v.Position - root.Position).Magnitude
				table.insert(candidates, {Part = v, Distance = dist})
			end
		end

		table.sort(candidates, function(a, b) return a.Distance > b.Distance end)

		for i = 1, FORCE_REMOVE_FAR_COUNT do
			if candidates[i] then
				local target = candidates[i].Part
				-- 再次確認沒被刪過 (雖然上面篩選過，但保險起見)
				if target.CanCollide == true then
					table.insert(_G.StoredWalls, target)
					target.CanCollide = false
					deletedCount = deletedCount + 1 -- 這裡刪的也要加進去
				end
			end
		end
	end

	_G.WallsGone = true

	-- [[ 顯示統計通知 ]] --
	StarterGui:SetCore("SendNotification", {
		Title = "Remove Walls";
		Text = "Found: " .. foundCount .. " | Deleted: " .. deletedCount;
		Duration = 5;
	})

else
	-- [[ 恢復原狀 ]] --
	local restoreCount = 0
	if _G.StoredWalls then
		for _, v in pairs(_G.StoredWalls) do
			if v then 
				v.CanCollide = true 
				restoreCount = restoreCount + 1
			end
		end
	end
	_G.StoredWalls = nil
	_G.WallsGone = false

	StarterGui:SetCore("SendNotification", {
		Title = "Restored";
		Text = "Restored " .. restoreCount .. " walls back to normal";
		Duration = 3;
	})
end
