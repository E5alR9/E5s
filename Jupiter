-- [[ ğŸª æœ¨æ˜Ÿ 25.0 - å¼·åˆ¶å‹•æ…‹å¹³è¡¡ç‰ˆï¼š100ä¸‹åˆª / 115ä¸Šè£œ ]]
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local p = game:GetService("Players").LocalPlayer
local jupiterTag = "E5_Jupiter_Dynamic_Final"

-- 1. æ¸…ç†èˆŠé‚è¼¯
local existing = workspace:FindFirstChild(jupiterTag)
if existing then
	_G.jupiterActive = false
	existing:Destroy()
	if _G.oldLighting then
		Lighting.ClockTime = _G.oldLighting.Time
		Lighting.Brightness = _G.oldLighting.Brightness
		Lighting.OutdoorAmbient = _G.oldLighting.Outdoor
		_G.oldLighting = nil
	end
	return 
end

-- 2. å•Ÿå‹•ç’°å¢ƒ
_G.jupiterActive = true
_G.oldLighting = {
	Time = Lighting.ClockTime,
	Brightness = Lighting.Brightness,
	Outdoor = Lighting.OutdoorAmbient
}

Lighting.ClockTime = 0
Lighting.Brightness = 0
Lighting.OutdoorAmbient = Color3.fromRGB(0, 0, 0)

local container = Instance.new("Model")
container.Name = jupiterTag
container.Parent = workspace

local jupiterRadius = 250
local bodyCount = 10000 
local ringCount = 3500 

local activeBody, inactiveBody = {}, {}
local activeRing, inactiveRing = {}, {}
local moons = {}

-- 3. æœ¨æ˜Ÿæœ¬é«”æ•¸æ“šåˆå§‹åŒ–
for i = 1, bodyCount do
	local offset = 2 / bodyCount
	local inc = math.pi * (3 - math.sqrt(5))
	local y = ((i - 1) * offset - 1) + (offset / 2)
	local r = math.sqrt(1 - math.pow(y, 2))
	local phi = i * inc
	local isDetail = (i % 2 == 0)
	
	local data = {
		Size = isDetail and Vector3.new(10, 10, 10) or Vector3.new(22, 22, 22),
		RadiusAtY = r * jupiterRadius,
		YPos = y * jupiterRadius,
		InitialPhi = phi,
		Lat = y, U = phi, V = y,
		Obj = nil
	}
	
	local prt = Instance.new("Part")
	prt.Size = data.Size
	prt.Material, prt.Anchored, prt.CanCollide = Enum.Material.Neon, true, false
	prt.Parent = container
	data.Obj = prt
	table.insert(activeBody, data)
end

-- 4. é»‘è‰²éš•çŸ³ç’°åˆå§‹åŒ–
for i = 1, ringCount do
	local rad = jupiterRadius * 1.5 + (math.random() * jupiterRadius * 1.3)
	local g = math.random(10, 35)
	local data = {
		Rad = rad, Angle = math.random()*6,
		Spd = 0.04/(math.sqrt(rad)*0.1), H = (math.random()-0.5)*35,
		Size = Vector3.new(1,1,1) * (math.random()*6+2),
		Color = Color3.fromRGB(g, g, g),
		RotAxis = Vector3.new(math.random(),math.random(),math.random()).Unit, RotSpd = math.random()*3,
		Obj = nil
	}
	local prt = Instance.new("Part")
	prt.Shape, prt.Size, prt.Color = Enum.PartType.Ball, data.Size, data.Color
	prt.Material, prt.Anchored, prt.CanCollide = Enum.Material.Basalt, true, false
	prt.Parent = container
	data.Obj = prt
	table.insert(activeRing, data)
end

-- 5. è¡›æ˜Ÿåˆå§‹åŒ–
local moonData = {
	{Col = Color3.fromRGB(255, 220, 50), Rad = 600, Spd = 0.012, Size = 15},
	{Col = Color3.fromRGB(160, 200, 255), Rad = 900, Spd = 0.009, Size = 12},
	{Col = Color3.fromRGB(180, 180, 180), Rad = 1300, Spd = 0.006, Size = 22},
	{Col = Color3.fromRGB(120, 100, 90), Rad = 1700, Spd = 0.004, Size = 20}
}
for _, m in ipairs(moonData) do
	local group = {}
	for j = 1, 350 do
		local pPart = Instance.new("Part")
		pPart.Shape, pPart.Size, pPart.Material = Enum.PartType.Ball, Vector3.new(3,3,3), Enum.Material.Neon
		pPart.Anchored, pPart.CanCollide, pPart.Color = true, false, m.Col
		pPart.Parent = container
		local v = Vector3.new(math.random()-0.5, math.random()-0.5, math.random()-0.5).Unit * m.Size
		table.insert(group, {Obj = pPart, LPos = v})
	end
	table.insert(moons, {Parts = group, Config = m, Angle = math.random()*6})
end

-- 6. å¼·åˆ¶å¹³è¡¡æ¸²æŸ“å¾ªç’°
task.spawn(function()
	local t, fps = 0, 144
	local tilt = CFrame.Angles(math.rad(20), 0, math.rad(10))

	while _G.jupiterActive and container.Parent do
		local dt = RunService.RenderStepped:Wait()
		fps = 0.9 * fps + 0.1 * (1 / dt)
		t = t + 0.004

		local root = p.Character and p.Character:FindFirstChild("HumanoidRootPart")
		if root then
			local center = root.Position + Vector3.new(1200, 500, -1200)
			
			-- ã€æ ¸å¿ƒï¼šFPS 100/115 å‹•æ…‹å®ˆé–€å“¡ã€‘
			if fps < 100 then
				-- éš¨æ©Ÿåˆªé™¤æœ¬é«”ç²’å­
				if #activeBody > 500 then
					for i = 1, 60 do
						local rIdx = math.random(#activeBody)
						local data = table.remove(activeBody, rIdx)
						if data.Obj then data.Obj:Destroy(); data.Obj = nil; table.insert(inactiveBody, data) end
					end
				end
				-- éš¨æ©Ÿåˆªé™¤éš•çŸ³
				if #activeRing > 300 then
					for i = 1, 30 do
						local rIdx = math.random(#activeRing)
						local data = table.remove(activeRing, rIdx)
						if data.Obj then data.Obj:Destroy(); data.Obj = nil; table.insert(inactiveRing, data) end
					end
				end
			elseif fps > 115 then
				-- FPS å›å‡ï¼Œè£œå›ç²’å­
				for i = 1, 15 do
					if #inactiveBody == 0 then break end
					local data = table.remove(inactiveBody, math.random(#inactiveBody))
					local prt = Instance.new("Part")
					prt.Size, prt.Material, prt.Anchored, prt.CanCollide = data.Size, Enum.Material.Neon, true, false
					prt.Parent = container
					data.Obj = prt
					table.insert(activeBody, data)
				end
			end

			-- æ¸²æŸ“æœ¬é«” (ä¿æŒåŠå¾‘ä¸è®Š)
			for _, d in ipairs(activeBody) do
				if d.Obj then
					local diffSpd = (1 - math.abs(d.Lat) * 0.4) * t * 0.2
					local currentPhi = d.InitialPhi + diffSpd
					local noise = math.noise(d.U * 0.5, d.V * 2, t * 0.3)
					local wave = (math.sin(d.V * 12 + noise * 7) + 1) / 2
					d.Obj.Color = Color3.fromRGB(180, 90, 30):lerp(Color3.fromRGB(255, 210, 150), wave)
					d.Obj.Position = center + (tilt * Vector3.new(math.cos(currentPhi)*d.RadiusAtY, d.YPos, math.sin(currentPhi)*d.RadiusAtY))
				end
			end

			-- æ¸²æŸ“éš•çŸ³
			for _, d in ipairs(activeRing) do
				if d.Obj then
					d.Angle = d.Angle + d.Spd * 0.4
					local pos = center + (tilt * Vector3.new(math.cos(d.Angle)*d.Rad, d.H, math.sin(d.Angle)*d.Rad))
					d.Obj.CFrame = CFrame.new(pos) * tilt * CFrame.fromAxisAngle(d.RotAxis, t * d.RotSpd)
				end
			end

			-- æ¸²æŸ“è¡›æ˜Ÿ
			for _, m in ipairs(moons) do
				m.Angle = m.Angle + m.Config.Spd
				local mC = center + (tilt * Vector3.new(math.cos(m.Angle)*m.Config.Rad, 0, math.sin(m.Angle)*m.Config.Rad))
				for _, mp in ipairs(m.Parts) do mp.Obj.Position = mC + mp.LPos end
			end
		end
	end
end)
