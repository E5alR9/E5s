-- [[ ğŸª æœ¨æ˜Ÿ 30.0 - åŸ·è¡Œå³é–‹é—œæ§åˆ¶ç‰ˆ ]]
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local p = game:GetService("Players").LocalPlayer
local jupiterTag = "E5_Jupiter_Switch_System"

-- ã€1. é–‹é—œæ ¸å¿ƒé‚è¼¯ã€‘
local existing = workspace:FindFirstChild(jupiterTag)
if existing then
	-- å¦‚æœæœ¨æ˜Ÿå·²å­˜åœ¨ï¼ŒåŸ·è¡Œé—œé–‰é‚è¼¯
	_G.jupiterActive = false
	_G.jupiterSession = nil
	existing:Destroy()
	
	-- æ¢å¾©å¤©ç©ºç’°å¢ƒ
	if _G.oldLighting then
		Lighting.ClockTime = _G.oldLighting.Time
		Lighting.Brightness = _G.oldLighting.Brightness
		Lighting.OutdoorAmbient = _G.oldLighting.Outdoor
		_G.oldLighting = nil
	else
		Lighting.ClockTime = 14
		Lighting.Brightness = 2
		Lighting.OutdoorAmbient = Color3.fromRGB(127, 127, 127)
	end
	print("æœ¨æ˜Ÿç³»çµ±å·²é—œé–‰")
	return -- ç›´æ¥çµæŸè…³æœ¬ï¼Œä¸åŸ·è¡Œå¾ŒçºŒç”Ÿæˆ
end

-- ã€2. å•Ÿå‹•é‚è¼¯ã€‘
print("æœ¨æ˜Ÿç³»çµ±å•Ÿå‹•ä¸­...")
local currentSession = tick()
_G.jupiterSession = currentSession
_G.jupiterActive = true

-- å„²å­˜ç•¶å‰ç’°å¢ƒä»¥ä¾¿ç¨å¾Œæ¢å¾©
_G.oldLighting = {
	Time = Lighting.ClockTime,
	Brightness = Lighting.Brightness,
	Outdoor = Lighting.OutdoorAmbient
}

-- è¨­ç½®å®‡å®™å…¨é»‘ç’°å¢ƒ
Lighting.ClockTime = 0
Lighting.Brightness = 0
Lighting.OutdoorAmbient = Color3.fromRGB(0, 0, 0)

-- å‰µå»ºå®¹å™¨
local container = Instance.new("Model")
container.Name = jupiterTag
container.Parent = workspace

local jupiterRadius = 250
local bodyCount = 10000 
local ringCount = 3500 

local activeBody, inactiveBody = {}, {}
local activeRing, inactiveRing = {}, {}
local moons = {}

-- 3. æœ¬é«”ç”Ÿæˆ (Tab ç¸®é€²)
for i = 1, bodyCount do
	local offset = 2 / bodyCount
	local inc = math.pi * (3 - math.sqrt(5))
	local y = ((i - 1) * offset - 1) + (offset / 2)
	local r = math.sqrt(1 - math.pow(y, 2))
	local phi = i * inc
	local isDetail = (i % 2 == 0)
	
	local data = {
		Size = isDetail and Vector3.new(10, 10, 10) or Vector3.new(22, 22, 22),
		RadiusAtY = r * jupiterRadius,
		YPos = y * jupiterRadius,
		InitialPhi = phi,
		Lat = y, U = phi, V = y,
		Obj = nil
	}
	
	local prt = Instance.new("Part")
	prt.Size = data.Size
	prt.Material, prt.Anchored, prt.CanCollide = Enum.Material.Neon, true, false
	prt.Parent = container
	data.Obj = prt
	table.insert(activeBody, data)
end

-- 4. é»‘è‰²éš•çŸ³ç’°ç”Ÿæˆ
for i = 1, ringCount do
	local rad = jupiterRadius * 1.5 + (math.random() * jupiterRadius * 1.3)
	local g = math.random(10, 35)
	local data = {
		Rad = rad, Angle = math.random()*6,
		Spd = 0.04/(math.sqrt(rad)*0.1), H = (math.random()-0.5)*35,
		Size = Vector3.new(1,1,1) * (math.random()*6+2),
		Color = Color3.fromRGB(g, g, g),
		RotAxis = Vector3.new(math.random(),math.random(),math.random()).Unit, RotSpd = math.random()*3,
		Obj = nil
	}
	local prt = Instance.new("Part")
	prt.Shape, prt.Size, prt.Color = Enum.PartType.Ball, data.Size, data.Color
	prt.Material, prt.Anchored, prt.CanCollide = Enum.Material.Basalt, true, false
	prt.Parent = container
	data.Obj = prt
	table.insert(activeRing, data)
end

-- 5. è¡›æ˜Ÿç³»çµ±
local moonData = {
	{Col = Color3.fromRGB(255, 220, 50), Rad = 600, Spd = 0.003, Size = 15},
	{Col = Color3.fromRGB(160, 200, 255), Rad = 900, Spd = 0.002, Size = 12},
	{Col = Color3.fromRGB(180, 180, 180), Rad = 1300, Spd = 0.0015, Size = 22},
	{Col = Color3.fromRGB(120, 100, 90), Rad = 1700, Spd = 0.001, Size = 20}
}
for _, m in ipairs(moonData) do
	local group = {}
	for j = 1, 350 do
		local pPart = Instance.new("Part")
		pPart.Shape, pPart.Size, pPart.Material = Enum.PartType.Ball, Vector3.new(3,3,3), Enum.Material.Neon
		pPart.Anchored, pPart.CanCollide, pPart.Color = true, false, m.Col
		pPart.Parent = container
		local v = Vector3.new(math.random()-0.5, math.random()-0.5, math.random()-0.5).Unit * m.Size
		table.insert(group, {Obj = pPart, LPos = v})
	end
	table.insert(moons, {Parts = group, Config = m, Angle = math.random()*6})
end

-- 6. å¼·åˆ¶å¹³è¡¡æ¸²æŸ“å¾ªç’°
task.spawn(function()
	local t, fps = 0, 144
	local tilt = CFrame.Angles(math.rad(20), 0, math.rad(10))

	while _G.jupiterActive and _G.jupiterSession == currentSession and container.Parent do
		local dt = RunService.RenderStepped:Wait()
		fps = 0.9 * fps + 0.1 * (1 / dt)
		t = t + 0.0012 -- æ…¢é€Ÿè‡ªè½‰

		local root = p.Character and p.Character:FindFirstChild("HumanoidRootPart")
		if root then
			local center = root.Position + Vector3.new(1200, 500, -1200)
			
			-- ã€å‹•æ…‹å¹³è¡¡ï¼š100ä¸‹åˆª / 115ä¸Šè£œã€‘
			if fps < 100 then
				if #activeBody > 500 then
					for i = 1, 100 do
						local rIdx = math.random(#activeBody)
						local data = table.remove(activeBody, rIdx)
						if data.Obj then data.Obj:Destroy(); data.Obj = nil; table.insert(inactiveBody, data) end
					end
				end
			elseif fps > 115 then
				for i = 1, 25 do
					if #inactiveBody == 0 then break end
					local data = table.remove(inactiveBody, math.random(#inactiveBody))
					local prt = Instance.new("Part")
					prt.Size, prt.Material, prt.Anchored, prt.CanCollide = data.Size, Enum.Material.Neon, true, false
					prt.Parent = container
					data.Obj = prt
					table.insert(activeBody, data)
				end
			end

			-- æ¸²æŸ“æœ¬é«”
			for _, d in ipairs(activeBody) do
				if d.Obj then
					local diffSpd = (1 - math.abs(d.Lat) * 0.4) * t * 0.2
					local currentPhi = d.InitialPhi + diffSpd
					local noise = math.noise(d.U * 0.5, d.V * 2, t * 0.3)
					local wave = (math.sin(d.V * 12 + noise * 7) + 1) / 2
					d.Obj.Color = Color3.fromRGB(180, 90, 30):lerp(Color3.fromRGB(255, 210, 150), wave)
					d.Obj.Position = center + (tilt * Vector3.new(math.cos(currentPhi)*d.RadiusAtY, d.YPos, math.sin(currentPhi)*d.RadiusAtY))
				end
			end

			-- æ¸²æŸ“éš•çŸ³èˆ‡è¡›æ˜Ÿ
			for _, d in ipairs(activeRing) do
				if d.Obj then
					d.Angle = d.Angle + d.Spd * 0.1
					local pos = center + (tilt * Vector3.new(math.cos(d.Angle)*d.Rad, d.H, math.sin(d.Angle)*d.Rad))
					d.Obj.CFrame = CFrame.new(pos) * tilt * CFrame.fromAxisAngle(d.RotAxis, t * d.RotSpd)
				end
			end
			for _, m in ipairs(moons) do
				m.Angle = m.Angle + m.Config.Spd
				local mC = center + (tilt * Vector3.new(math.cos(m.Angle)*m.Config.Rad, 0, math.sin(m.Angle)*m.Config.Rad))
				for _, mp in ipairs(m.Parts) do mp.Obj.Position = mC + mp.LPos end
			end
		end
	end
end)
