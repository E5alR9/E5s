-- [[ ğŸª æœ¨æ˜Ÿ 19.0 - å…¨åŸŸéš¨æ©Ÿå‹•æ…‹å¹³è¡¡ç‰ˆ ]]
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local p = game:GetService("Players").LocalPlayer
local jupiterTag = "E5_Jupiter_DynamicBalance"

local existing = workspace:FindFirstChild(jupiterTag)
if existing then
	_G.jupiterActive = false
	existing:Destroy()
	if _G.oldLighting then
		Lighting.ClockTime = _G.oldLighting.Time
		Lighting.Brightness = _G.oldLighting.Brightness
		Lighting.OutdoorAmbient = _G.oldLighting.Outdoor
		_G.oldLighting = nil
	end
	return 
else
	_G.jupiterActive = true
	_G.oldLighting = {Time = Lighting.ClockTime, Brightness = Lighting.Brightness, Outdoor = Lighting.OutdoorAmbient}

	Lighting.ClockTime = 0
	Lighting.Brightness = 0
	Lighting.OutdoorAmbient = Color3.fromRGB(0, 0, 0)

	local container = Instance.new("Model", workspace)
	container.Name = jupiterTag

	local jupiterRadius = 250
	local bodyCount = 10000 
	local ringCount = 3500 
	
	-- æ•¸æ“šå„²å­˜æ± 
	local activeBody = {}   -- æœ¬é«”
	local inactiveBody = {} 
	local activeRing = {}   -- éš•çŸ³ç’°
	local inactiveRing = {}

	-- 1. æœ¨æ˜Ÿæœ¬é«”æ•¸æ“šåˆå§‹åŒ– (å®Œå…¨ä¿ç•™åŸå§‹æ‡¸è‡‚/çƒé«”å‡½æ•¸)
	for i = 1, bodyCount do
		local offset = 2 / bodyCount
		local inc = math.pi * (3 - math.sqrt(5))
		local y = ((i - 1) * offset - 1) + (offset / 2)
		local r = math.sqrt(1 - math.pow(y, 2))
		local phi = i * inc
		local isDetail = (i % 2 == 0)
		
		local data = {
			Size = isDetail and Vector3.new(10, 10, 10) or Vector3.new(22, 22, 22),
			RadiusAtY = r * jupiterRadius,
			YPos = y * jupiterRadius,
			InitialPhi = phi,
			Lat = y, U = phi, V = y,
			Instance = nil
		}
		
		-- åˆå§‹åŠ è¼‰å¯¦é«”
		local prt = Instance.new("Part", container)
		prt.Size = data.Size
		prt.Material, prt.Anchored, prt.CanCollide = Enum.Material.Neon, true, false
		data.Instance = prt
		table.insert(activeBody, data)
	end

	-- 2. é»‘è‰²éš•çŸ³ç’°æ•¸æ“šåˆå§‹åŒ–
	for i = 1, ringCount do
		local rad = jupiterRadius * 1.5 + (math.random() * jupiterRadius * 1.3)
		local g = math.random(10, 35)
		local data = {
			Rad = rad, Angle = math.random()*6,
			Spd = 0.04/(math.sqrt(rad)*0.1), H = (math.random()-0.5)*35,
			Size = Vector3.new(1,1,1) * (math.random()*6+2),
			Color = Color3.fromRGB(g, g, g),
			RotAxis = Vector3.new(math.random(),math.random(),math.random()).Unit, 
			RotSpd = math.random()*3,
			Instance = nil
		}
		
		local prt = Instance.new("Part", container)
		prt.Shape, prt.Size, prt.Color = Enum.PartType.Ball, data.Size, data.Color
		prt.Material, prt.Anchored, prt.CanCollide = Enum.Material.Basalt, true, false
		data.Instance = prt
		table.insert(activeRing, data)
	end

	-- 3. è¡›æ˜Ÿç³»çµ± (è¼ƒè¼•é‡ï¼Œä¸åƒèˆ‡éš¨æ©Ÿåˆªé™¤ä»¥ä¿æŒåœ°æ¨™å¯è¦‹)
	local moons = {}
	local moonData = {
		{Name = "Io", Col = Color3.fromRGB(255, 220, 50), Rad = 600, Spd = 0.012, Size = 15},
		{Name = "Europa", Col = Color3.fromRGB(160, 200, 255), Rad = 900, Spd = 0.009, Size = 12},
		{Name = "Ganymede", Col = Color3.fromRGB(180, 180, 180), Rad = 1300, Spd = 0.006, Size = 22},
		{Name = "Callisto", Col = Color3.fromRGB(120, 100, 90), Rad = 1700, Spd = 0.004, Size = 20}
	}
	for _, m in ipairs(moonData) do
		local g = {}
		for j = 1, 350 do
			local p = Instance.new("Part", container)
			p.Shape, p.Size, p.Material = Enum.PartType.Ball, Vector3.new(3,3,3), Enum.Material.Neon
			p.Anchored, p.CanCollide, p.Color = true, false, m.Col
			local v = Vector3.new(math.random()-0.5, math.random()-0.5, math.random()-0.5).Unit * m.Size
			table.insert(g, {Obj = p, LPos = v})
		end
		table.insert(moons, {Parts = g, Config = m, Angle = math.random()*6})
	end

	-- æ¸²æŸ“å¾ªç’°
	task.spawn(function()
		local t, fps = 0, 144
		local tilt = CFrame.Angles(math.rad(20), 0, math.rad(10))
		
		while _G.jupiterActive and container.Parent do
			local dt = RunService.RenderStepped:Wait()
			fps = 0.9 * fps + 0.1 * (1 / dt)
			t = t + 0.004
			
			local root = p.Character and p.Character:FindFirstChild("HumanoidRootPart")
			if root then
				local center = root.Position + Vector3.new(1200, 500, -1200)

				-- ã€æœ¨æ˜Ÿéš¨æ©Ÿå¹³è¡¡é‚è¼¯ï¼šåªåˆªå¯†åº¦ï¼Œä¸æ”¹åŠå¾‘ã€‘
				if fps < 100 then
					-- åˆªé™¤æœ¬é«”ç²’å­
					if #activeBody > 500 then
						for i = 1, 30 do
							local rIdx = math.random(#activeBody)
							local data = table.remove(activeBody, rIdx)
							if data and data.Instance then data.Instance:Destroy(); data.Instance = nil; table.insert(inactiveBody, data) end
						end
					end
					-- åˆªé™¤éš•çŸ³ç’°ç²’å­
					if #activeRing > 300 then
						for i = 1, 15 do
							local rIdx = math.random(#activeRing)
							local data = table.remove(activeRing, rIdx)
							if data and data.Instance then data.Instance:Destroy(); data.Instance = nil; table.insert(inactiveRing, data) end
						end
					end
				elseif fps > 115 then
					-- è£œå›æœ¬é«”
					for i = 1, 15 do
						if #inactiveBody == 0 then break end
						local data = table.remove(inactiveBody, math.random(#inactiveBody))
						local prt = Instance.new("Part", container)
						prt.Size = data.Size
						prt.Material, prt.Anchored, prt.CanCollide = Enum.Material.Neon, true, false
						data.Instance = prt
						table.insert(activeBody, data)
					end
					-- è£œå›éš•çŸ³
					for i = 1, 8 do
						if #inactiveRing == 0 then break end
						local data = table.remove(inactiveRing, math.random(#inactiveRing))
						local prt = Instance.new("Part", container)
						prt.Shape, prt.Size, prt.Color = Enum.PartType.Ball, data.Size, data.Color
						prt.Material, prt.Anchored, prt.CanCollide = Enum.Material.Basalt, true, false
						data.Instance = prt
						table.insert(activeRing, data)
					end
				end

				-- æ¸²æŸ“æœ¨æ˜Ÿæœ¬é«”
				for _, d in ipairs(activeBody) do
					local diffSpd = (1 - math.abs(d.Lat) * 0.4) * t * 0.2
					local currentPhi = d.InitialPhi + diffSpd
					local noise = math.noise(d.U * 0.5, d.V * 2, t * 0.3)
					local wave = (math.sin(d.V * 12 + noise * 7) + 1) / 2
					d.Obj.Color = Color3.fromRGB(180, 90, 30):lerp(Color3.fromRGB(255, 210, 150), wave)
					d.Obj.Position = center + (tilt * Vector3.new(math.cos(currentPhi)*d.RadiusAtY, d.YPos, math.sin(currentPhi)*d.RadiusAtY))
				end
				
				-- æ¸²æŸ“éš•çŸ³ç’°
				for _, d in ipairs(activeRing) do
					d.Angle = d.Angle + d.Spd * 0.4
					local pos = center + (tilt * Vector3.new(math.cos(d.Angle)*d.Rad, d.H, math.sin(d.Angle)*d.Rad))
					d.Obj.CFrame = CFrame.new(pos) * tilt * CFrame.fromAxisAngle(d.RotAxis, t * d.RotSpd)
				end

				-- æ¸²æŸ“è¡›æ˜Ÿ
				for _, m in ipairs(moons) do
					m.Angle = m.Angle + m.Config.Spd
					local mC = center + (tilt * Vector3.new(math.cos(m.Angle)*m.Config.Rad, 0, math.sin(m.Angle)*m.Config.Rad))
					for _, mp in ipairs(m.Parts) do mp.Obj.Position = mC + mp.LPos end
				end
			end
		end
	end)
end
