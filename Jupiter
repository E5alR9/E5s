-- [[ ğŸª æœ¨æ˜Ÿ 18.0 - ç´”ç²’å­ç³»çµ±ï¼šç„¡æ ¸å¿ƒçƒé«”ã€é»‘è‰²éš•çŸ³ã€å››å¤§è¡›æ˜Ÿ ]]
local Lighting = game:GetService("Lighting")
local p = game:GetService("Players").LocalPlayer
local jupiterTag = "E5_Jupiter_Pure_Particle"

local existing = workspace:FindFirstChild(jupiterTag)
if existing then
	_G.jupiterActive = false
	existing:Destroy()
	return 
else
	_G.jupiterActive = true
	Lighting.ClockTime = 0
	Lighting.Brightness = 0
	Lighting.OutdoorAmbient = Color3.fromRGB(0, 0, 0)

	local container = Instance.new("Model", workspace)
	container.Name = jupiterTag

	local jupiterRadius = 250
	local bodyCount = 10000 -- å¢åŠ æœ¬é«”ç²’å­æ•¸ä»¥å¡«è£œç§»é™¤æ ¸å¿ƒå¾Œçš„ç©ºéš™
	local ringCount = 3500 
	local bodyParts, ringParts, moons = {}, {}, {}

	-- 1. æœ¨æ˜Ÿæœ¬é«”ç”Ÿæˆ (ç´”ç²’å­å¡«æ»¿é‚è¼¯)
	for i = 1, bodyCount do
		local prt = Instance.new("Part", container)
		-- ä½¿ç”¨è¼ƒå¤§çš„ç²’å­ï¼ˆ18~22ï¼‰ä¾†å¾¹åº•å°é–é–“éš™
		local isDetail = (i % 2 == 0)
		prt.Size = isDetail and Vector3.new(10, 10, 10) or Vector3.new(22, 22, 22)
		prt.Material, prt.Anchored, prt.CanCollide = Enum.Material.Neon, true, false
		
		local offset = 2 / bodyCount
		local inc = math.pi * (3 - math.sqrt(5))
		local y = ((i - 1) * offset - 1) + (offset / 2)
		local r = math.sqrt(1 - math.pow(y, 2))
		local phi = i * inc
		
		table.insert(bodyParts, {
			Obj = prt,
			RadiusAtY = r * jupiterRadius,
			YPos = y * jupiterRadius,
			InitialPhi = phi,
			Lat = y, U = phi, V = y
		})
	end

	-- 2. é»‘è‰²éš•çŸ³ç’° (Basalt æè³ª)
	for i = 1, ringCount do
		local prt = Instance.new("Part", container)
		prt.Shape, prt.Size = Enum.PartType.Ball, Vector3.new(1,1,1) * (math.random()*6+2)
		prt.Material = Enum.Material.Basalt
		local g = math.random(10, 35)
		prt.Color = Color3.fromRGB(g, g, g)
		prt.Anchored, prt.CanCollide = true, false
		local rad = jupiterRadius * 1.5 + (math.random() * jupiterRadius * 1.3)
		table.insert(ringParts, {
			Obj = prt, Rad = rad, Angle = math.random()*6,
			Spd = 0.04/(math.sqrt(rad)*0.1), H = (math.random()-0.5)*35,
			RotAxis = Vector3.new(math.random(),math.random(),math.random()).Unit, RotSpd = math.random()*3
		})
	end

	-- 3. è¡›æ˜Ÿç³»çµ±
	local moonData = {
		{Name = "Io", Col = Color3.fromRGB(255, 220, 50), Rad = 600, Spd = 0.012, Size = 15},
		{Name = "Europa", Col = Color3.fromRGB(160, 200, 255), Rad = 900, Spd = 0.009, Size = 12},
		{Name = "Ganymede", Col = Color3.fromRGB(180, 180, 180), Rad = 1300, Spd = 0.006, Size = 22},
		{Name = "Callisto", Col = Color3.fromRGB(120, 100, 90), Rad = 1700, Spd = 0.004, Size = 20}
	}

	for _, m in ipairs(moonData) do
		local g = {}
		for j = 1, 350 do
			local p = Instance.new("Part", container)
			p.Shape, p.Size, p.Material = Enum.PartType.Ball, Vector3.new(3,3,3), Enum.Material.Neon
			p.Anchored, p.CanCollide, p.Color = true, false, m.Col
			local v = Vector3.new(math.random()-0.5, math.random()-0.5, math.random()-0.5).Unit * m.Size
			table.insert(g, {Obj = p, LPos = v})
		end
		table.insert(moons, {Parts = g, Config = m, Angle = math.random()*6})
	end

	task.spawn(function()
		local t = 0
		local tilt = CFrame.Angles(math.rad(20), 0, math.rad(10))
		while _G.jupiterActive and container.Parent do
			t = t + 0.004
			local root = p.Character and p.Character:FindFirstChild("HumanoidRootPart")
			if root then
				local center = root.Position + Vector3.new(1200, 500, -1200)
				
				-- æœ¨æ˜Ÿå·®ç•°è‡ªè½‰èˆ‡ Shadertoy è®Šè‰²
				for _, d in ipairs(bodyParts) do
					local diffSpd = (1 - math.abs(d.Lat) * 0.4) * t * 0.2
					local currentPhi = d.InitialPhi + diffSpd
					local noise = math.noise(d.U * 0.5, d.V * 2, t * 0.3)
					local wave = (math.sin(d.V * 12 + noise * 7) + 1) / 2
					d.Obj.Color = Color3.fromRGB(180, 90, 30):lerp(Color3.fromRGB(255, 210, 150), wave)
					d.Obj.Position = center + (tilt * Vector3.new(math.cos(currentPhi)*d.RadiusAtY, d.YPos, math.sin(currentPhi)*d.RadiusAtY))
				end
				
				-- éš•çŸ³ç¿»æ»¾
				for _, d in ipairs(ringParts) do
					d.Angle = d.Angle + d.Spd * 0.4
					local pos = center + (tilt * Vector3.new(math.cos(d.Angle)*d.Rad, d.H, math.sin(d.Angle)*d.Rad))
					d.Obj.CFrame = CFrame.new(pos) * tilt * CFrame.fromAxisAngle(d.RotAxis, t * d.RotSpd)
				end

				-- è¡›æ˜Ÿé‹è¡Œ
				for _, m in ipairs(moons) do
					m.Angle = m.Angle + m.Config.Spd
					local mC = center + (tilt * Vector3.new(math.cos(m.Angle)*m.Config.Rad, 0, math.sin(m.Angle)*m.Config.Rad))
					for _, mp in ipairs(m.Parts) do mp.Obj.Position = mC + mp.LPos end
				end
			end
			task.wait()
		end
	end)
end
