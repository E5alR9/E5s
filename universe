-- [[ üåå ÂÆáÂÆôÁ≥ªÁµ± 190.1 - 2000ÁïåÈôêÁâàÔºöÁ≤æÊ∫ñËá™ÁàÜÂõûÊî∂ / Èö®Ê©üÂÇæËßí / Tab Á∏ÆÈÄ≤ ]]
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local p = game:GetService("Players").LocalPlayer
local camera = workspace.CurrentCamera
local v188Tag = "Universe_Limit2000_V190_1"

-- „ÄêËÆäÊï∏Ë®≠ÂÆö„Äë
local isLockedToPlayer = true
local fixedAnchor = Vector3.new(0, 0, 0)
local blackHoles = {}
local zoomOffset = 0 
local systems = {}
local remnants = {}
local CLEAN_LIMIT = 2000 -- Âö¥Ê†ºÈÇäÁïåË®≠ÂÆö

-- „ÄêZ ÈçµÂæ™Áí∞ÊîæÂ§ßÈÇèËºØ„Äë
UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.KeyCode == Enum.KeyCode.P then
		isLockedToPlayer = not isLockedToPlayer
		if not isLockedToPlayer and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
			fixedAnchor = p.Character.HumanoidRootPart.Position
		end
	elseif input.KeyCode == Enum.KeyCode.Z then
		if zoomOffset > 5 then zoomOffset = 0 end
	end
end)

local function toggleSystem()
	local existing = workspace:FindFirstChild(v188Tag)
	if existing then
		_G.v188Active = false; existing:Destroy()
		Lighting.ClockTime, Lighting.Brightness, Lighting.OutdoorAmbient = 14, 2, Color3.fromRGB(127, 127, 127)
		return true
	end
	return false
end
if toggleSystem() then return end

_G.v188Active = true
local currentSession = tick()
_G.v188Session = currentSession
Lighting.ClockTime, Lighting.Brightness, Lighting.OutdoorAmbient, Lighting.GlobalShadows = 0, 0, Color3.new(0,0,0), false
local container = Instance.new("Model", workspace); container.Name = v188Tag

-- „ÄêÊ†∏ÂøÉÁ¢éÁâáÁ≥ªÁµ±Ôºö2000ÁïåÈôêËá™ÁàÜ„Äë
local function createStellarRemnant(pos, col, isExpelling)
	local nearestBH = blackHoles[1]
	for i = 2, #blackHoles do
		if (pos - blackHoles[i].CurrentPos).Magnitude < (pos - nearestBH.CurrentPos).Magnitude then
			nearestBH = blackHoles[i]
		end
	end

	local count = isExpelling and 4 or 12 -- Ëá™ÁàÜÁ¢éÁâáÊõ¥Á≤æÁ∞°
	for i = 1, count do
		local f = Instance.new("Part", container)
		f.Size, f.Color, f.Material = Vector3.new(0.4, 0.4, 1.8), col, Enum.Material.Neon
		f.Anchored, f.CanCollide = true, false; f.Position = pos
		local trail = Instance.new("Trail", f)
		local a0 = Instance.new("Attachment", f); a0.Position = Vector3.new(0, 0.2, 0)
		local a1 = Instance.new("Attachment", f); a1.Position = Vector3.new(0, -0.2, 0)
		trail.Attachment0, trail.Attachment1, trail.Lifetime = a0, a1, 0.4
		trail.Color = ColorSequence.new(col)
		
		local vecToBH = (nearestBH.CurrentPos - pos)
		local vel
		if isExpelling then
			-- ÂêëÂ§ñÂô¥ÁôºÔºöÈö®Ê©üÈ´òÈÄü
			vel = Vector3.new(math.random(-60, 60), math.random(-60, 60), math.random(-60, 60))
		else
			-- Âê∏Á©çÁπûË°å
			local tangent = Vector3.new(-vecToBH.Z, 0, vecToBH.X).Unit
			local dir = (math.random() > 0.5 and 1 or -1)
			vel = (tangent * dir * (10 + math.random()*4))
		end

		table.insert(remnants, {
			Obj = f, 
			Life = 1.0, 
			Decay = isExpelling and 0.03 or 0.0008, 
			Velocity = vel, 
			TargetBH = nearestBH,
			OrbitDir = 1,
			ChaosFactor = isExpelling and 1.02 or 0.98,
			IsExpelling = isExpelling
		})
	end
end

-- „ÄêÂ§©È´îÁîüÊàê„Äë
local function createPlanet()
	local pCol = (math.random() > 0.5 and Color3.fromRGB(130, 130, 130) or Color3.fromRGB(160, 110, 70))
	local pObj = Instance.new("Part", container)
	pObj.Shape, pObj.Size, pObj.Color, pObj.Material = Enum.PartType.Ball, Vector3.new(0.8, 0.8, 0.8), pCol, Enum.Material.Plastic
	pObj.Anchored, pObj.CanCollide = true, false
	return {Obj = pObj, OrbitR = 18 + math.random() * 25, Angle = math.random() * 6.2, RotSpeed = 0.015, BaseCol = pCol}
end

local function createSolarSystem()
	local r = math.random(500, CLEAN_LIMIT)
	local sys = {Stars = {}, Planets = {}, Radius = r, Phi = math.rad(math.random(360)), Theta = math.acos(math.random()), Speed = 0.00015, GravShift = Vector3.new(0,0,0), randomTilt = CFrame.Angles(math.rad(math.random(360)), math.rad(math.random(360)), math.rad(math.random(360)))}
	local rV = math.random()*100
	local col, sz = Color3.fromRGB(255,255,255), 4.5
	if rV<5 then col, sz = Color3.fromRGB(155,176,255), 9 elseif rV<15 then col, sz = Color3.fromRGB(202,215,255), 6.5 elseif rV<75 then col, sz = Color3.fromRGB(255,245,180), 3.5 else col, sz = Color3.fromRGB(255,100,100), 2.5 end
	local s = Instance.new("Part", container); s.Shape, s.Size, s.Material, s.Color = Enum.PartType.Ball, Vector3.new(sz,sz,sz), Enum.Material.Neon, col; s.Anchored, s.CanCollide = true, false
	table.insert(sys.Stars, {Obj = s, BaseCol = col})
	for i = 1, math.random(1, 4) do table.insert(sys.Planets, createPlanet()) end
	return sys
end

-- „ÄêÂàùÂßãÂåñÈªëÊ¥û„Äë
local function createBH(hOffset)
	local core = Instance.new("Part", container); core.Shape, core.Size, core.Material, core.Color = Enum.PartType.Ball, Vector3.new(45,45,45), Enum.Material.Neon, Color3.new(0,0,0); core.Anchored, core.CanCollide = true, false
	return {Core = core, Offset = hOffset, CurrentPos = Vector3.new()}
end
table.insert(blackHoles, createBH(Vector2.new(-1200, 1100)))
table.insert(blackHoles, createBH(Vector2.new(800, -1500)))

-- „ÄêÊ†∏ÂøÉÂæ™Áí∞„Äë
task.spawn(function()
	local t = 0
	while _G.v188Active and _G.v188Session == currentSession do
		local dt = RunService.RenderStepped:Wait()
		t = t + 0.04
		local fps = 1/dt
		local rp = isLockedToPlayer and ((p.Character and p.Character:FindFirstChild("HumanoidRootPart")) and p.Character.HumanoidRootPart.Position or Vector3.new(0,0,0)) or fixedAnchor

		if UserInputService:IsKeyDown(Enum.KeyCode.Z) then zoomOffset = zoomOffset + 10 end
		if zoomOffset > 0.5 then camera.CFrame = camera.CFrame * CFrame.new(0, 0, -zoomOffset) end
		
		-- Á∂≠ÊåÅ 2000 ÁØÑÂúçÂÖßÁöÑÊòüÁ≥ªÊï∏Èáè
		if fps >= 60 or #systems < 350 then table.insert(systems, createSolarSystem()) end

		for idx, bh in ipairs(blackHoles) do
			bh.CurrentPos = rp + Vector3.new(math.cos(t*0.005+idx)*bh.Offset.X, 400, math.sin(t*0.005+idx)*bh.Offset.Y)
			bh.Core.Position = bh.CurrentPos
		end

		for i = #systems, 1, -1 do
			local s1 = systems[i]
			local starObj = s1.Stars[1].Obj
			local starPos = starObj.Position
			local distFromCenter = (starPos - rp).Magnitude
			
			local inBHRange = false
			for _, bh in ipairs(blackHoles) do
				if (starPos - bh.CurrentPos).Magnitude < 500 then inBHRange = true; break end
			end

			-- „Äê2000 ÁïåÈôêÊ∏ÖÁêÜÈÇèËºØ„Äë
			local isOutOfBounds = distFromCenter > CLEAN_LIMIT
			local shouldSelfDestruct = (fps < 60 and isOutOfBounds and not inBHRange)

			if isOutOfBounds or shouldSelfDestruct then 
				createStellarRemnant(starPos, s1.Stars[1].BaseCol, shouldSelfDestruct)
				starObj:Destroy()
				for _, pl in ipairs(s1.Planets) do pl.Obj:Destroy() end
				table.remove(systems, i) continue 
			end

			-- Ê≠£Â∏∏ÈÅãÂãïÈÇèËºØ...
			s1.Phi = s1.Phi + s1.Speed
			local bP = rp + Vector3.new(s1.Radius * math.sin(s1.Theta) * math.cos(s1.Phi), s1.Radius * math.cos(s1.Theta), s1.Radius * math.sin(s1.Theta) * math.sin(s1.Phi))
			local tbh = (starPos - blackHoles[1].CurrentPos).Magnitude < (starPos - blackHoles[2].CurrentPos).Magnitude and blackHoles[1] or blackHoles[2]
			local dist = (starPos - tbh.CurrentPos).Magnitude
			
			s1.GravShift = s1.GravShift:Lerp((tbh.CurrentPos - bP).Unit * ((dist < 400 and (1-dist/400)*3 or 0) * 400), 0.05)
			local curSysPos = bP + s1.GravShift
			starObj.Position = curSysPos
			
			local exploded = (dist < 45)
			for _, pl in ipairs(s1.Planets) do
				pl.Angle = pl.Angle + pl.RotSpeed
				pl.Obj.Position = curSysPos + s1.randomTilt:VectorToWorldSpace(Vector3.new(math.cos(pl.Angle)*pl.OrbitR, 0, math.sin(pl.Angle)*pl.OrbitR))
				if exploded or (pl.Obj.Position - tbh.CurrentPos).Magnitude < 45 then 
					createStellarRemnant(pl.Obj.Position, pl.BaseCol, false)
					pl.Obj:Destroy()
				end
			end
			if exploded then 
				createStellarRemnant(curSysPos, s1.Stars[1].BaseCol, false)
				starObj:Destroy()
				for _, pl in ipairs(s1.Planets) do if pl.Obj.Parent then pl.Obj:Destroy() end end
				table.remove(systems, i) 
			end
		end

		-- Á¢éÁâá 2000 ÁïåÈôêÂõûÊî∂
		for i = #remnants, 1, -1 do
			local r = remnants[i]
			r.Life = r.Life - r.Decay
			local bhPos = r.TargetBH.CurrentPos
			local vecToBH = bhPos - r.Obj.Position
			local dist = vecToBH.Magnitude
			
			-- ‰ªª‰ΩïÁâ©È´îÂè™Ë¶ÅÈõ¢ÈñãÁé©ÂÆ∂ 2000 ÂñÆ‰ΩçÂ∞±Âà™Èô§
			local outOfLimit = (r.Obj.Position - rp).Magnitude > CLEAN_LIMIT

			if r.Life <= 0 or dist < 22 or outOfLimit then 
				r.Obj:Destroy(); table.remove(remnants, i)
			else
				if r.IsExpelling then
					r.Velocity = r.Velocity * r.ChaosFactor
				else
					local targetVel = (vecToBH.Unit * (10 + (dist * 0.06)) + Vector3.new(-vecToBH.Z, 0, vecToBH.X).Unit * (r.OrbitDir * 8.5))
					r.Velocity = r.Velocity:Lerp(targetVel, 0.12) * r.ChaosFactor
				end
				r.Obj.Position = r.Obj.Position + r.Velocity
				r.Obj.Transparency = 1 - r.Life
				r.Obj.CFrame = CFrame.new(r.Obj.Position, r.Obj.Position + r.Velocity)
			end
		end
	end
end)
