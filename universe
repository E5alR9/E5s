-- [[ ğŸŒŒ å®‡å®™ç³»çµ± 192.25 - å…¨åŸŸéš¨æ©Ÿå‚¾è§’ç‰ˆï¼šå››æ®µæ¨é€² / å¾ªåºè€æ­» / ç«‹é«”æ†æ˜Ÿè»Œé“ / Tab ç¸®é€² ]]
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local p = game:GetService("Players").LocalPlayer
local camera = workspace.CurrentCamera
local v188Tag = "Universe_FullStereo_V192_25"

-- ã€è®Šæ•¸è¨­å®šã€‘
local isLockedToPlayer = true
local fixedAnchor = Vector3.new(0, 0, 0)
local blackHoles = {}
local zoomLevel = 0 
local lerpDolly = 0 
local systems = {}
local remnants = {}
local CLEAN_LIMIT = 2000 
local ATTRACT_DIST = 150

-- ã€åˆ‡æ›èˆ‡æ¢å¾©é‚è¼¯ã€‘
local function toggleSystem()
	local existing = workspace:FindFirstChild(v188Tag)
	if existing then
		_G.v188Active = false
		existing:Destroy()
		Lighting.ClockTime, Lighting.Brightness = 14, 2
		Lighting.OutdoorAmbient = Color3.fromRGB(127, 127, 127)
		Lighting.GlobalShadows = true
		return true
	end
	return false
end
if toggleSystem() then return end

-- ã€å¿«æ·éµåµæ¸¬ã€‘
UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.KeyCode == Enum.KeyCode.P then isLockedToPlayer = not isLockedToPlayer
	elseif input.KeyCode == Enum.KeyCode.Z then 
		zoomLevel = (zoomLevel + 1) % 4 
	end
end)

_G.v188Active = true
local currentSession = tick()
_G.v188Session = currentSession
Lighting.ClockTime, Lighting.Brightness, Lighting.OutdoorAmbient, Lighting.GlobalShadows = 0, 0, Color3.new(0,0,0), false
local container = Instance.new("Model", workspace); container.Name = v188Tag

-- ã€æ ¸å¿ƒç¢ç‰‡ç³»çµ±ï¼šéš¨æ©Ÿå‚¾è§’èºæ—‹ã€‘
local function createStellarRemnant(pos, col, isExpelling)
	local nearestBH = blackHoles[1]
	for i = 2, #blackHoles do
		if (pos - blackHoles[i].CurrentPos).Magnitude < (pos - nearestBH.CurrentPos).Magnitude then
			nearestBH = blackHoles[i]
		end
	end
	
	local randomUp = Vector3.new(math.random()-0.5, math.random()-0.5, math.random()-0.5).Unit
	local count = isExpelling and 4 or 7 
	
	for i = 1, count do
		local f = Instance.new("Part", container)
		f.Size, f.Color, f.Material = Vector3.new(0.3, 0.3, 1.5), col, Enum.Material.Neon
		f.Anchored, f.CanCollide = true, false; f.Position = pos
		local a0 = Instance.new("Attachment", f); a0.Position = Vector3.new(0, 0.15, 0)
		local a1 = Instance.new("Attachment", f); a1.Position = Vector3.new(0, -0.15, 0)
		local tr = Instance.new("Trail", f); tr.Attachment0, tr.Attachment1, tr.Lifetime = a0, a1, 0.3; tr.Color = ColorSequence.new(col)
		
		local vecToBH = (nearestBH.CurrentPos - pos)
		local orbitDir = (math.random() > 0.5 and 1 or -1)
		local tangent = vecToBH.Unit:Cross(randomUp).Unit
		local vel = isExpelling and Vector3.new(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) 
					or (tangent * orbitDir * (12 + math.random() * 6))

		table.insert(remnants, {
			Obj = f, Life = 1.0, Decay = isExpelling and 0.03 or 0.0004, 
			Velocity = vel, TargetBH = nearestBH, InwardBias = 0.1, 
			IsExpelling = isExpelling, OrbitDir = orbitDir, OrbitUp = randomUp,
			IsCaptured = false, OrbitTimer = 0, MaxOrbitTime = 60 + math.random(-2, 10),
			CaptureStartDist = 0
		})
	end
end

-- ã€å¤©é«”ç”Ÿæˆï¼šåŠ å…¥éš¨æ©Ÿè»Œé“å¹³é¢ã€‘
local function createSolarSystem(rp)
	local r = math.random(500, CLEAN_LIMIT)
	-- ç”Ÿæˆä¸€å€‹éš¨æ©Ÿçš„ç³»çµ±å‘ä¸Šå‘é‡ï¼Œæ±ºå®šè©²æ˜Ÿç³»çš„è»Œé“å¹³é¢
	local systemUp = Vector3.new(math.random()-0.5, math.random()-0.5, math.random()-0.5).Unit
	local sys = {
		Stars = {}, Planets = {}, Radius = r, Phi = math.rad(math.random(360)), 
		Speed = 0.0001 + math.random() * 0.0002, 
		SystemUp = systemUp, 
		GravShift = Vector3.new(0,0,0),
		randomTilt = CFrame.lookAt(Vector3.zero, systemUp) -- ç”¨æ–¼è¡Œæ˜Ÿè»Œé“å°é½Š
	}
	
	local rV = math.random()*100
	local col, sz = Color3.fromRGB(255,255,255), 4.5
	if rV<5 then col, sz = Color3.fromRGB(155,176,255), 9 elseif rV<15 then col, sz = Color3.fromRGB(202,215,255), 6.5 elseif rV<75 then col, sz = Color3.fromRGB(255,245,180), 3.5 else col, sz = Color3.fromRGB(255,100,100), 2.5 end
	
	local s = Instance.new("Part", container); s.Shape, s.Size, s.Material, s.Color = Enum.PartType.Ball, Vector3.new(sz,sz,sz), Enum.Material.Neon, col; s.Anchored, s.CanCollide = true, false
	table.insert(sys.Stars, {Obj = s, BaseCol = col, Radius = sz/2})
	
	for i = 1, math.random(1, 4) do
		local pCol = (math.random()>0.5 and Color3.fromRGB(130,130,130) or Color3.fromRGB(160,110,70))
		local pObj = Instance.new("Part", container); pObj.Shape, pObj.Size, pObj.Color, pObj.Material = Enum.PartType.Ball, Vector3.new(0.8,0.8,0.8), pCol, Enum.Material.Plastic; pObj.Anchored, pObj.CanCollide = true, false
		table.insert(sys.Planets, {Obj = pObj, OrbitR = 18+math.random()*25, Angle = math.random()*6, RotSpeed = 0.015, BaseCol = pCol})
	end
	return sys
end

-- ã€é»‘æ´åˆå§‹åŒ–ã€‘
local function createBH(hOffset)
	local core = Instance.new("Part", container); core.Shape, core.Size, core.Material, core.Color = Enum.PartType.Ball, Vector3.new(45,45,45), Enum.Material.Neon, Color3.new(0,0,0); core.Anchored, core.CanCollide = true, false
	return {Core = core, Offset = hOffset, CurrentPos = Vector3.new()}
end
table.insert(blackHoles, createBH(Vector2.new(-1200, 1100)))
table.insert(blackHoles, createBH(Vector2.new(800, -1500)))

-- ã€ä¸»å¾ªç’°ã€‘
task.spawn(function()
	local t = 0
	while _G.v188Active and _G.v188Session == currentSession do
		local dt = RunService.RenderStepped:Wait()
		t = t + 0.04
		local fps = 1/dt
		local rp = isLockedToPlayer and ((p.Character and p.Character:FindFirstChild("HumanoidRootPart")) and p.Character.HumanoidRootPart.Position or Vector3.new(0,0,0)) or fixedAnchor

		-- å››æ®µæ¨é€²
		local targetDolly = (zoomLevel == 0 and 0) or (zoomLevel == 1 and 400) or (zoomLevel == 2 and 800) or 1200
		lerpDolly = lerpDolly + (targetDolly - lerpDolly) * 0.1
		if lerpDolly > 1 then camera.CFrame = camera.CFrame * CFrame.new(0, 0, -lerpDolly) end
		
		if fps >= 60 and #systems < 350 then table.insert(systems, createSolarSystem(rp)) end

		for idx, bh in ipairs(blackHoles) do
			bh.CurrentPos = rp + Vector3.new(math.cos(t*0.005+idx)*bh.Offset.X, 400, math.sin(t*0.005+idx)*bh.Offset.Y)
			bh.Core.Position = bh.CurrentPos
		end

		-- æ†æ˜Ÿé‹å‹•ï¼šç«‹é«”è»Œé“
		local hasAged = false
		for i = #systems, 1, -1 do
			local s1 = systems[i]; local starObj = s1.Stars[1].Obj; local starPos = starObj.Position
			local tbh = (starPos - blackHoles[1].CurrentPos).Magnitude < (starPos - blackHoles[2].CurrentPos).Magnitude and blackHoles[1] or blackHoles[2]
			local distBH = (starPos - tbh.CurrentPos).Magnitude
			
			if (fps < 60 and not hasAged and distBH > 500 and #systems > 50) or (starPos-rp).Magnitude > CLEAN_LIMIT then
				hasAged = true
				createStellarRemnant(starPos, s1.Stars[1].BaseCol, true)
				starObj:Destroy(); for _, pl in ipairs(s1.Planets) do pl.Obj:Destroy() end
				table.remove(systems, i) continue
			end

			s1.Phi = s1.Phi + s1.Speed
			-- åœ¨éš¨æ©Ÿå‚¾æ–œçš„è»Œé“å¹³é¢ä¸Šè¨ˆç®—ä½ç½®
			local right = s1.SystemUp:Cross(Vector3.new(0,1,0)).Magnitude > 0.1 and s1.SystemUp:Cross(Vector3.new(0,1,0)).Unit or s1.SystemUp:Cross(Vector3.new(1,0,0)).Unit
			local forward = s1.SystemUp:Cross(right).Unit
			local bP = rp + (right * math.cos(s1.Phi) * s1.Radius) + (forward * math.sin(s1.Phi) * s1.Radius)
			
			s1.GravShift = s1.GravShift:Lerp((tbh.CurrentPos - bP).Unit * ((distBH < 400 and (1-distBH/400)*3 or 0) * 400), 0.05)
			local curSysPos = bP + s1.GravShift
			starObj.Position = curSysPos
			
			for _, pl in ipairs(s1.Planets) do
				pl.Angle = pl.Angle + pl.RotSpeed
				pl.Obj.Position = curSysPos + s1.randomTilt:VectorToWorldSpace(Vector3.new(math.cos(pl.Angle)*pl.OrbitR, 0, math.sin(pl.Angle)*pl.OrbitR))
			end

			if distBH < 45 then 
				createStellarRemnant(curSysPos, s1.Stars[1].BaseCol, false)
				starObj:Destroy(); for _, pl in ipairs(s1.Planets) do pl.Obj:Destroy() end
				table.remove(systems, i) 
			end
		end

		-- ç¢ç‰‡èºæ—‹
		for i = #remnants, 1, -1 do
			local r = remnants[i]
			local vecToBH = r.TargetBH.CurrentPos - r.Obj.Position
			local dist = vecToBH.Magnitude
			
			if not r.IsCaptured then
				r.Life = r.Life - r.Decay
				if r.Life <= 0 or (r.Obj.Position - rp).Magnitude > CLEAN_LIMIT then r.Obj:Destroy(); table.remove(remnants, i); continue end
				if dist < 50 then r.IsCaptured = true; r.CaptureStartDist = dist; r.Velocity = r.Velocity * 0.5
				else r.Velocity = r.Velocity:Lerp(vecToBH.Unit * 6, 0.05) end
			else
				r.OrbitTimer = r.OrbitTimer + (1/60)
				local progress = math.min(r.OrbitTimer / r.MaxOrbitTime, 1)
				local targetRadius = r.CaptureStartDist * (1 - progress) + (10 * progress)
				local orbitTangent = vecToBH.Unit:Cross(r.OrbitUp).Unit * r.OrbitDir * (16 + progress * 10)
				r.Velocity = r.Velocity:Lerp(orbitTangent + vecToBH.Unit * (dist - targetRadius) * 2, 0.1)
				r.Obj.Transparency = progress * 0.8
				if progress >= 1 then r.Obj:Destroy(); table.remove(remnants, i) end
			end
			if r.Obj.Parent then
				r.Obj.Position = r.Obj.Position + r.Velocity; r.Obj.CFrame = CFrame.new(r.Obj.Position, r.Obj.Position + r.Velocity)
			end
		end
	end
end)
