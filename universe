-- [[ ğŸŒŒ å®‡å®™ç³»çµ± 183.0 - V179 æ ¸å¿ƒ / 2800 é‚Šç•Œè£å‰ª / ç¬æ®ºåå™¬ / ä¸‰ç‰¹è‰²é»‘æ´ / Tab ç¸®é€² ]]
local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")
local p = game:GetService("Players").LocalPlayer
local v179Tag = "Universe_BoundaryOpt_V183"

-- ã€1. ç’°å¢ƒç®¡ç†èˆ‡é–‹é—œã€‘
local function toggleSystem()
	local existing = workspace:FindFirstChild(v179Tag)
	if existing then
		_G.v179Active = false; existing:Destroy()
		Lighting.ClockTime, Lighting.Brightness, Lighting.OutdoorAmbient = 14, 2, Color3.fromRGB(127, 127, 127)
		Lighting.GlobalShadows = true
		return true
	end
	return false
end
if toggleSystem() then return end

_G.v179Active = true
local currentSession = tick()
_G.v179Session = currentSession
Lighting.ClockTime, Lighting.Brightness, Lighting.OutdoorAmbient, Lighting.GlobalShadows = 0, 0, Color3.new(0,0,0), false

local container = Instance.new("Model", workspace); container.Name = v179Tag

-- ã€2. ç•™ç—•èˆ‡æ•¸æ“šç³»çµ±ã€‘
local remnants = {}
local function createStellarRemnant(pos, col, bhPos)
	for i = 1, 4 do
		local f = Instance.new("Part", container)
		f.Size, f.Color, f.Material = Vector3.new(1.4, 1.4, 1.4), col, Enum.Material.Neon
		f.Anchored, f.CanCollide, f.Position = true, false, pos
		table.insert(remnants, {
			Obj = f, Life = 1.0, Angle = math.random()*math.pi*2, 
			OrbitR = (pos - bhPos).Magnitude * 0.8,
			Speed = 0.04 + math.random()*0.05, Center = bhPos
		})
	end
end

local function getStellarData()
	local rand = math.random() * 100
	if rand < 1 then return Color3.fromRGB(155, 176, 255), 7.5 
	elseif rand < 10 then return Color3.fromRGB(202, 215, 255), 5.0 
	elseif rand < 40 then return Color3.fromRGB(255, 244, 234), 3.5 
	elseif rand < 70 then return Color3.fromRGB(255, 210, 161), 2.8 
	else return Color3.fromRGB(255, 100, 100), 2.2 end
end

-- ã€3. ä¸‰å¤§ç‰¹è‰²é»‘æ´ã€‘
local blackHoles = {}
local function createBH(hOffset, bhType)
	local bhData = {Type = bhType, Core = nil, ActiveOrbs = {}, Offset = hOffset, CurrentPos = Vector3.new(), Tilt = CFrame.Angles(math.rad(25), 0, math.rad(15))}
	local core = Instance.new("Part", container); core.Shape, core.Size, core.Material, core.Color = Enum.PartType.Ball, Vector3.new(50, 50, 50), Enum.Material.Neon, Color3.new(0,0,0)
	core.Anchored, core.CanCollide = true, false; bhData.Core = core
	local pCount = (bhType == "Spiral") and 700 or 450
	for i = 1, pCount do
		local r, ang, armOff = 0, math.random()*math.pi*2, 0
		if bhType == "Spiral" then 
			local arm, prog = (i%2==0) and 0 or math.pi, i/pCount
			r = 25 + prog*115; ang = arm + prog*5.5; armOff = (math.random()-0.5)*12*(1-prog)
		elseif bhType == "Cloud" then
			r = 25 + math.random()*90; ang = math.random()*math.pi*2; armOff = (math.random()-0.5)*15
		else
			r = 22 + math.sqrt(i/pCount)*80; ang = math.random()*math.pi*2
		end
		table.insert(bhData.ActiveOrbs, {BaseRadius = r, Angle = ang, RotSpeed = 0.08/(r^0.3), Part = nil, Seed = math.random(1000), ArmOff = armOff})
	end
	return bhData
end

table.insert(blackHoles, createBH(Vector2.new(1250, -850), "Classic"))
table.insert(blackHoles, createBH(Vector2.new(-1250, 1150), "Spiral"))
table.insert(blackHoles, createBH(Vector2.new(650, -1650), "Cloud"))

-- ã€4. æ˜Ÿç³»ç”Ÿæˆã€‘
local systems, roguePlanets = {}, {}
local function createSolarSystem()
	local r, p, th = math.random(750, 2800), math.rad(math.random(360)), math.acos(math.random())
	local col, size = getStellarData()
	local sun = Instance.new("Part", container); sun.Shape, sun.Size, sun.Material, sun.Color = Enum.PartType.Ball, Vector3.new(size,size,size), Enum.Material.Neon, col
	sun.Anchored, sun.CanCollide = true, false
	local sys = {Obj = sun, BaseSize = size, BaseCol = col, Planets = {}, Radius = r, Phi = p, Theta = th, Speed = (math.random()>0.5 and 1 or -1)*0.00018, GravShift = Vector3.new(0,0,0), InterGrav = Vector3.new(0,0,0)}
	for j = 1, math.random(1, 3) do
		local pPart = Instance.new("Part", container); pPart.Shape, pPart.Size, pPart.Material = Enum.PartType.Ball, Vector3.new(1.2, 1.2, 1.2), Enum.Material.Neon
		pPart.Color, pPart.Anchored, pPart.CanCollide = Color3.fromRGB(150, 200, 255), true, false
		table.insert(sys.Planets, {Obj = pPart, OrbitR = size * 2.6 + math.random()*12, OrbitAngle = math.random()*360, OrbitSpeed = 0.04 + math.random()*0.08})
	end
	return sys
end

local function createRoguePlanet()
	local pPart = Instance.new("Part", container); pPart.Shape, pPart.Size, pPart.Material = Enum.PartType.Ball, Vector3.new(1.6, 1.6, 1.6), Enum.Material.Neon
	pPart.Color, pPart.Anchored, pPart.CanCollide = Color3.fromRGB(70, 50, 130), true, false
	return {Obj = pPart, Pos = Vector3.new(math.random(-2800, 2800), math.random(150, 650), math.random(-2800, 2800)), Vel = Vector3.new(math.random(-2,2), math.random(-1,1), math.random(-2,2)), BaseCol = pPart.Color}
end

-- ã€5. æ ¸å¿ƒå¾ªç’°ã€‘
task.spawn(function()
	local t, updateStep = 0, 0
	for i = 1, 750 do table.insert(systems, createSolarSystem()) end
	for i = 1, 50 do table.insert(roguePlanets, createRoguePlanet()) end

	while _G.v179Active and _G.v179Session == currentSession do
		local dt = RunService.RenderStepped:Wait()
		t, updateStep = t + 0.04, updateStep + 1
		local rp = (p.Character and p.Character:FindFirstChild("HumanoidRootPart")) and p.Character.HumanoidRootPart.Position or Vector3.new(0,0,0)

		-- é»‘æ´æ¸²æŸ“
		for idx, bh in ipairs(blackHoles) do
			bh.CurrentPos = rp + Vector3.new(math.cos(t*0.005+idx)*bh.Offset.X, 350+math.sin(t*0.02)*40, math.sin(t*0.005+idx)*bh.Offset.Y)
			if bh.Core then bh.Core.Position = bh.CurrentPos end
			for _, d in ipairs(bh.ActiveOrbs) do
				if not d.Part then d.Part = Instance.new("Part", container); d.Part.Shape, d.Part.Size, d.Part.Material, d.Part.Anchored, d.Part.CanCollide = Enum.PartType.Ball, Vector3.new(1.2,1.2,1.2), Enum.Material.Neon, true, false end
				d.Angle = d.Angle + d.RotSpeed
				local yOff = (bh.Type == "Cloud") and math.sin(t + d.Seed)*15 or math.sin(t*0.5 + d.Seed)*0.5
				d.Part.Position = bh.CurrentPos + (bh.Tilt * Vector3.new(math.cos(d.Angle)*d.BaseRadius + d.ArmOff, yOff, math.sin(d.Angle)*d.BaseRadius + d.ArmOff))
				d.Part.Color = (bh.Type == "Spiral") and Color3.fromRGB(100, 160, 255) or (bh.Type == "Cloud" and Color3.fromRGB(255, 180, 50) or Color3.fromRGB(255, 90, 40))
			end
		end

		-- æµæµªè¡Œæ˜Ÿç‰©ç† (åŠ ä¸Š 2800 é‚Šç•Œè£å‰ª)
		for i = #roguePlanets, 1, -1 do
			local rP = roguePlanets[i]
			local distToPlayer = (rP.Pos - rp).Magnitude
			if not rP.Obj or not rP.Obj.Parent or rP.Pos.Y < -100 or distToPlayer > 3000 then 
				if rP.Obj then rP.Obj:Destroy() end
				table.remove(roguePlanets, i); table.insert(roguePlanets, createRoguePlanet()) continue 
			end
			local targetBH = blackHoles[1]; local dMin = (rP.Pos - targetBH.CurrentPos).Magnitude
			for j=2, #blackHoles do
				local d = (rP.Pos - blackHoles[j].CurrentPos).Magnitude
				if d < dMin then dMin = d; targetBH = blackHoles[j] end
			end
			if dMin < 40 then 
				createStellarRemnant(rP.Pos, rP.BaseCol, targetBH.CurrentPos)
				rP.Obj:Destroy(); table.remove(roguePlanets, i); table.insert(roguePlanets, createRoguePlanet())
				continue
			end
			local f = (dMin < 700) and (1-(dMin/700))^2 or 0
			rP.Vel = rP.Vel + (targetBH.CurrentPos - rP.Pos).Unit * f * 2
			rP.Pos = rP.Pos + rP.Vel; rP.Obj.Position = rP.Pos
		end

		-- æ†æ˜Ÿèˆ‡è¡Œæ˜Ÿ (åŠ ä¸Š 2800 é‚Šç•Œè£å‰ª)
		for i = #systems, 1, -1 do
			local s1 = systems[i]
			-- å¦‚æœåº§æ¨™è·é›¢ç©å®¶è¶…é 2800ï¼Œç›´æ¥åˆªé™¤
			local distToPlayer = s1.Obj and (s1.Obj.Position - rp).Magnitude or 0
			if not s1.Obj or not s1.Obj.Parent or s1.Obj.Position.Y < -100 or distToPlayer > 2900 then 
				if s1.Obj then s1.Obj:Destroy() end
				for _,pd in ipairs(s1.Planets) do if pd.Obj then pd.Obj:Destroy() end end
				table.remove(systems, i); continue 
			end

			s1.Phi = s1.Phi + s1.Speed
			local oPos = rp + Vector3.new(s1.Radius * math.sin(s1.Theta) * math.cos(s1.Phi), s1.Radius * math.cos(s1.Theta), s1.Radius * math.sin(s1.Theta) * math.sin(s1.Phi))
			local targetBH = blackHoles[1]; local dMin = (s1.Obj.Position - targetBH.CurrentPos).Magnitude
			for j=2, #blackHoles do
				local d = (s1.Obj.Position - blackHoles[j].CurrentPos).Magnitude
				if d < dMin then dMin = d; targetBH = blackHoles[j] end
			end

			-- ç¬æ®ºåˆ¤å®š
			if dMin < 40 then 
				createStellarRemnant(s1.Obj.Position, s1.BaseCol, targetBH.CurrentPos)
				s1.Obj:Destroy(); for _,pd in ipairs(s1.Planets) do if pd.Obj then pd.Obj:Destroy() end end
				table.remove(systems, i); continue
			end

			local f = (dMin < 650) and (1-(dMin/650))^2 or 0
			s1.GravShift = s1.GravShift:Lerp((targetBH.CurrentPos - oPos).Unit * (f * 230), 0.05)
			
			-- äº’å¸é‚è¼¯ (ä¿ç•™ V179)
			if (i + updateStep) % 4 == 0 then
				local starGrav = Vector3.new(0,0,0)
				for j = 1, 5 do
					local s2 = systems[math.random(1, #systems)]
					if s2 and s1 ~= s2 and s2.Obj.Parent then
						local dS = (s1.Obj.Position - s2.Obj.Position).Magnitude
						if dS < 150 then starGrav = starGrav + (s2.Obj.Position - s1.Obj.Position).Unit * (1-dS/150)*14 end
					end
				end
				s1.InterGrav = s1.InterGrav:Lerp(starGrav, 0.1)
			end
			
			local finalPos = oPos + s1.GravShift + s1.InterGrav
			s1.Obj.Position = finalPos
			
			-- éºµæ¢åŒ–
			if f > 0.05 then
				s1.Obj.Size = Vector3.new(s1.BaseSize, s1.BaseSize + f*80, s1.BaseSize)
				s1.Obj.CFrame = CFrame.new(finalPos, targetBH.CurrentPos) * CFrame.Angles(math.pi/2, 0, 0)
			else s1.Obj.Size = Vector3.new(s1.BaseSize, s1.BaseSize, s1.BaseSize) end

			-- è¡Œæ˜Ÿæ›´æ–° (ä¿ç•™ V179)
			for _, pData in ipairs(s1.Planets) do
				if pData.Obj and pData.Obj.Parent then
					pData.OrbitAngle = pData.OrbitAngle + pData.OrbitSpeed
					local relPos = Vector3.new(math.cos(pData.OrbitAngle)*pData.OrbitR, 0, math.sin(pData.OrbitAngle)*pData.OrbitR)
					local pPos = finalPos + relPos
					if f > 0.05 then
						pData.Obj.Position = pPos:Lerp(targetBH.CurrentPos, f * 0.9)
						pData.Obj.Size = Vector3.new(1.2, 1.2 + f*35, 1.2)
						pData.Obj.CFrame = CFrame.new(pData.Obj.Position, targetBH.CurrentPos) * CFrame.Angles(math.pi/2, 0, 0)
					else
						pData.Obj.Position = pPos; pData.Obj.Size = Vector3.new(1.2, 1.2, 1.2)
					end
				end
			end
		end
		
		-- ç—•è·¡æ¸…ç†
		for i = #remnants, 1, -1 do
			local rem = remnants[i]
			rem.Life = rem.Life - 0.005
			if rem.Life <= 0 or not rem.Obj.Parent then rem.Obj:Destroy(); table.remove(remnants, i)
			else
				rem.Angle = rem.Angle + rem.Speed
				rem.Obj.Position = rem.Center + Vector3.new(math.cos(rem.Angle)*rem.OrbitR, math.sin(t+rem.Angle), math.sin(rem.Angle)*rem.OrbitR)
				rem.Obj.Transparency = 1 - rem.Life
			end
		end

		if #systems < 650 then table.insert(systems, createSolarSystem()) end
	end
end)
